{"version":3,"sources":["../node_modules/prismjs/components/prism-puppet.js"],"names":["Prism","languages","puppet","pattern","lookbehind","alias","inside","greedy","interpolation","rest"],"mappings":"gHAAA,SAAWA,GACTA,EAAMC,UAAUC,OAAS,CACvB,QAAW,CACX,CACEC,QAAS,uGACTC,YAAY,EACZC,MAAO,SACPC,OAAQ,CAEN,YAAe,sBAInB,CACEH,QAAS,qGACTC,YAAY,EACZG,QAAQ,EACRF,MAAO,SACPC,OAAQ,CAEN,YAAe,sBAGnB,CACEH,QAAS,8CACTE,MAAO,SACPC,OAAQ,CACN,YAAe,CACbH,QAAS,gBACTC,YAAY,MAIlB,oBAAqB,CACnBD,QAAS,4BACTC,YAAY,EACZG,QAAQ,EACRF,MAAO,WAET,MAAS,CAEPF,QAAS,uFACTC,YAAY,EACZG,QAAQ,EACRD,OAAQ,CAEN,iBAAkB,CAChBH,QAAS,yCACTG,OAAQ,CACN,QAAW,UAKnB,QAAW,CACTH,QAAS,eACTC,YAAY,EACZG,QAAQ,GAEV,OAAU,CAERJ,QAAS,wFACTI,QAAQ,EACRD,OAAQ,CACN,gBAAiB,CACfH,QAAS,cACTG,OAAQ,MAKd,SAAY,CACVH,QAAS,yBACTG,OAAQ,CACN,YAAe,OAGnB,YAAa,sBACb,SAAY,CAAC,CACXH,QAAS,gBACTC,YAAY,GACX,oGACH,OAAU,+CACV,QAAW,qBAEX,QAAW,6IACX,SAAY,CACVD,QAAS,gNACTE,MAAO,UAET,SAAY,mFACZ,YAAe,oBAEjB,IAAIG,EAAgB,CAAC,CAEnBL,QAAS,0EACTC,YAAY,EACZE,OAAQ,CACN,iBAAkB,CAEhBH,QAAS,uCACTC,YAAY,EACZC,MAAO,WACPC,OAAQ,CACN,YAAe,OAGnB,UAAa,CACXH,QAAS,MACTE,MAAO,YAETI,KAAMT,EAAMC,UAAUC,SAEvB,CACDC,QAAS,kCACTC,YAAY,EACZC,MAAO,WACPC,OAAQ,CACN,YAAe,QAGnBN,EAAMC,UAAUC,OAAgB,QAAE,GAAGI,OAAOE,cAAgBA,EAC5DR,EAAMC,UAAUC,OAAe,OAAEI,OAAO,iBAAiBA,OAAOE,cAAgBA,EA1HlF,CA2HGR","file":"static/js/307.da4f6c5c.chunk.js","sourcesContent":["(function (Prism) {\n  Prism.languages.puppet = {\n    'heredoc': [// Matches the content of a quoted heredoc string (subject to interpolation)\n    {\n      pattern: /(@\\(\"([^\"\\r\\n\\/):]+)\"(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n      lookbehind: true,\n      alias: 'string',\n      inside: {\n        // Matches the end tag\n        'punctuation': /(?=\\S).*\\S(?= *$)/ // See interpolation below\n\n      }\n    }, // Matches the content of an unquoted heredoc string (no interpolation)\n    {\n      pattern: /(@\\(([^\"\\r\\n\\/):]+)(?:\\/[nrts$uL]*)?\\).*(?:\\r?\\n|\\r))(?:.*(?:\\r?\\n|\\r))*?[ \\t]*\\|?[ \\t]*-?[ \\t]*\\2/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'string',\n      inside: {\n        // Matches the end tag\n        'punctuation': /(?=\\S).*\\S(?= *$)/\n      }\n    }, // Matches the start tag of heredoc strings\n    {\n      pattern: /@\\(\"?(?:[^\"\\r\\n\\/):]+)\"?(?:\\/[nrts$uL]*)?\\)/,\n      alias: 'string',\n      inside: {\n        'punctuation': {\n          pattern: /(\\().+?(?=\\))/,\n          lookbehind: true\n        }\n      }\n    }],\n    'multiline-comment': {\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n      lookbehind: true,\n      greedy: true,\n      alias: 'comment'\n    },\n    'regex': {\n      // Must be prefixed with the keyword \"node\" or a non-word char\n      pattern: /((?:\\bnode\\s+|[~=\\(\\[\\{,]\\s*|[=+]>\\s*|^\\s*))\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/(?:[imx]+\\b|\\B)/,\n      lookbehind: true,\n      greedy: true,\n      inside: {\n        // Extended regexes must have the x flag. They can contain single-line comments.\n        'extended-regex': {\n          pattern: /^\\/(?:[^\\/\\\\]|\\\\[\\s\\S])+\\/[im]*x[im]*$/,\n          inside: {\n            'comment': /#.*/\n          }\n        }\n      }\n    },\n    'comment': {\n      pattern: /(^|[^\\\\])#.*/,\n      lookbehind: true,\n      greedy: true\n    },\n    'string': {\n      // Allow for one nested level of double quotes inside interpolation\n      pattern: /([\"'])(?:\\$\\{(?:[^'\"}]|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}|(?!\\1)[^\\\\]|\\\\[\\s\\S])*\\1/,\n      greedy: true,\n      inside: {\n        'double-quoted': {\n          pattern: /^\"[\\s\\S]*\"$/,\n          inside: {// See interpolation below\n          }\n        }\n      }\n    },\n    'variable': {\n      pattern: /\\$(?:::)?\\w+(?:::\\w+)*/,\n      inside: {\n        'punctuation': /::/\n      }\n    },\n    'attr-name': /(?:\\w+|\\*)(?=\\s*=>)/,\n    'function': [{\n      pattern: /(\\.)(?!\\d)\\w+/,\n      lookbehind: true\n    }, /\\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\\b|\\b(?!\\d)\\w+(?=\\()/],\n    'number': /\\b(?:0x[a-f\\d]+|\\d+(?:\\.\\d+)?(?:e-?\\d+)?)\\b/i,\n    'boolean': /\\b(?:true|false)\\b/,\n    // Includes words reserved for future use\n    'keyword': /\\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\\b/,\n    'datatype': {\n      pattern: /\\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\\b/,\n      alias: 'symbol'\n    },\n    'operator': /=[=~>]?|![=~]?|<(?:<\\|?|[=~|-])?|>[>=]?|->?|~>|\\|>?>?|[*\\/%+?]|\\b(?:and|in|or)\\b/,\n    'punctuation': /[\\[\\]{}().,;]|:+/\n  };\n  var interpolation = [{\n    // Allow for one nested level of braces inside interpolation\n    pattern: /(^|[^\\\\])\\$\\{(?:[^'\"{}]|\\{[^}]*\\}|([\"'])(?:(?!\\2)[^\\\\]|\\\\[\\s\\S])*\\2)+\\}/,\n    lookbehind: true,\n    inside: {\n      'short-variable': {\n        // Negative look-ahead prevent wrong highlighting of functions\n        pattern: /(^\\$\\{)(?!\\w+\\()(?:::)?\\w+(?:::\\w+)*/,\n        lookbehind: true,\n        alias: 'variable',\n        inside: {\n          'punctuation': /::/\n        }\n      },\n      'delimiter': {\n        pattern: /^\\$/,\n        alias: 'variable'\n      },\n      rest: Prism.languages.puppet\n    }\n  }, {\n    pattern: /(^|[^\\\\])\\$(?:::)?\\w+(?:::\\w+)*/,\n    lookbehind: true,\n    alias: 'variable',\n    inside: {\n      'punctuation': /::/\n    }\n  }];\n  Prism.languages.puppet['heredoc'][0].inside.interpolation = interpolation;\n  Prism.languages.puppet['string'].inside['double-quoted'].inside.interpolation = interpolation;\n})(Prism);"],"sourceRoot":""}