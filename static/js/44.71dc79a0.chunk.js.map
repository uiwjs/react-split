{"version":3,"sources":["../node_modules/codemirror/mode/dtd/dtd.js"],"names":["CodeMirror","defineMode","config","type","indentUnit","ret","style","tp","tokenBase","stream","state","quote","terminator","ch","next","eat","tokenize","eol","match","eatWhile","escaped","sc","current","substr","length","backUp","tokenSGMLComment","dashes","startState","base","baseIndent","stack","token","eatSpace","context","push","pop","indent","textAfter","n","electricChars","defineMIME","mod"],"mappings":"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","file":"static/js/44.71dc79a0.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/*\n  DTD mode\n  Ported to CodeMirror by Peter Kroon <plakroon@gmail.com>\n  Report bugs/issues here: https://github.com/codemirror/CodeMirror/issues\n  GitHub: @peterkroon\n*/\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"dtd\", function (config) {\n    var indentUnit = config.indentUnit,\n        type;\n\n    function ret(style, tp) {\n      type = tp;\n      return style;\n    }\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \"<\" && stream.eat(\"!\")) {\n        if (stream.eatWhile(/[\\-]/)) {\n          state.tokenize = tokenSGMLComment;\n          return tokenSGMLComment(stream, state);\n        } else if (stream.eatWhile(/[\\w]/)) return ret(\"keyword\", \"doindent\");\n      } else if (ch == \"<\" && stream.eat(\"?\")) {\n        //xml declaration\n        state.tokenize = inBlock(\"meta\", \"?>\");\n        return ret(\"meta\", ch);\n      } else if (ch == \"#\" && stream.eatWhile(/[\\w]/)) return ret(\"atom\", \"tag\");else if (ch == \"|\") return ret(\"keyword\", \"seperator\");else if (ch.match(/[\\(\\)\\[\\]\\-\\.,\\+\\?>]/)) return ret(null, ch); //if(ch === \">\") return ret(null, \"endtag\"); else\n      else if (ch.match(/[\\[\\]]/)) return ret(\"rule\", ch);else if (ch == \"\\\"\" || ch == \"'\") {\n          state.tokenize = tokenString(ch);\n          return state.tokenize(stream, state);\n        } else if (stream.eatWhile(/[a-zA-Z\\?\\+\\d]/)) {\n          var sc = stream.current();\n          if (sc.substr(sc.length - 1, sc.length).match(/\\?|\\+/) !== null) stream.backUp(1);\n          return ret(\"tag\", \"tag\");\n        } else if (ch == \"%\" || ch == \"*\") return ret(\"number\", \"number\");else {\n          stream.eatWhile(/[\\w\\\\\\-_%.{,]/);\n          return ret(null, null);\n        }\n    }\n\n    function tokenSGMLComment(stream, state) {\n      var dashes = 0,\n          ch;\n\n      while ((ch = stream.next()) != null) {\n        if (dashes >= 2 && ch == \">\") {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        dashes = ch == \"-\" ? dashes + 1 : 0;\n      }\n\n      return ret(\"comment\", \"comment\");\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            ch;\n\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && !escaped) {\n            state.tokenize = tokenBase;\n            break;\n          }\n\n          escaped = !escaped && ch == \"\\\\\";\n        }\n\n        return ret(\"string\", \"tag\");\n      };\n    }\n\n    function inBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenBase;\n            break;\n          }\n\n          stream.next();\n        }\n\n        return style;\n      };\n    }\n\n    return {\n      startState: function startState(base) {\n        return {\n          tokenize: tokenBase,\n          baseIndent: base || 0,\n          stack: []\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        var context = state.stack[state.stack.length - 1];\n        if (stream.current() == \"[\" || type === \"doindent\" || type == \"[\") state.stack.push(\"rule\");else if (type === \"endtag\") state.stack[state.stack.length - 1] = \"endtag\";else if (stream.current() == \"]\" || type == \"]\" || type == \">\" && context == \"rule\") state.stack.pop();else if (type == \"[\") state.stack.push(\"[\");\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        var n = state.stack.length;\n        if (textAfter.match(/\\]\\s+|\\]/)) n = n - 1;else if (textAfter.substr(textAfter.length - 1, textAfter.length) === \">\") {\n          if (textAfter.substr(0, 1) === \"<\") {} else if (type == \"doindent\" && textAfter.length > 1) {} else if (type == \"doindent\") n--;else if (type == \">\" && textAfter.length > 1) {} else if (type == \"tag\" && textAfter !== \">\") {} else if (type == \"tag\" && state.stack[state.stack.length - 1] == \"rule\") n--;else if (type == \"tag\") n++;else if (textAfter === \">\" && state.stack[state.stack.length - 1] == \"rule\" && type === \">\") n--;else if (textAfter === \">\" && state.stack[state.stack.length - 1] == \"rule\") {} else if (textAfter.substr(0, 1) !== \"<\" && textAfter.substr(0, 1) === \">\") n = n - 1;else if (textAfter === \">\") {} else n = n - 1; //over rule them all\n\n\n          if (type == null || type == \"]\") n--;\n        }\n        return state.baseIndent + n * indentUnit;\n      },\n      electricChars: \"]>\"\n    };\n  });\n  CodeMirror.defineMIME(\"application/xml-dtd\", \"dtd\");\n});"],"sourceRoot":""}