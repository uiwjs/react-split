{"version":3,"sources":["../node_modules/remark-parse/lib/util/interrupt.js","../node_modules/remark-parse/lib/util/normalize.js","../node_modules/remark-parse/lib/defaults.js","../node_modules/remark-parse/lib/util/get-indentation.js","../node_modules/remark-parse/lib/util/html.js","../node_modules/remark-parse/lib/locate/tag.js","../node_modules/remark-parse/lib/locate/link.js","../node_modules/remark-parse/index.js","../node_modules/remark-parse/lib/parser.js","../node_modules/remark-parse/lib/unescape.js","../node_modules/remark-parse/lib/decode.js","../node_modules/remark-parse/lib/tokenizer.js","../node_modules/remark-parse/lib/set-options.js","../node_modules/remark-parse/lib/parse.js","../node_modules/remark-parse/lib/tokenize/newline.js","../node_modules/remark-parse/lib/tokenize/code-indented.js","../node_modules/remark-parse/lib/tokenize/code-fenced.js","../node_modules/remark-parse/lib/tokenize/blockquote.js","../node_modules/remark-parse/lib/tokenize/heading-atx.js","../node_modules/remark-parse/lib/tokenize/thematic-break.js","../node_modules/remark-parse/lib/tokenize/list.js","../node_modules/remark-parse/lib/util/remove-indentation.js","../node_modules/remark-parse/lib/tokenize/heading-setext.js","../node_modules/remark-parse/lib/tokenize/html-block.js","../node_modules/remark-parse/lib/tokenize/footnote-definition.js","../node_modules/remark-parse/lib/tokenize/definition.js","../node_modules/remark-parse/lib/tokenize/table.js","../node_modules/remark-parse/lib/tokenize/paragraph.js","../node_modules/remark-parse/lib/tokenize/escape.js","../node_modules/remark-parse/lib/locate/escape.js","../node_modules/remark-parse/lib/tokenize/auto-link.js","../node_modules/remark-parse/lib/tokenize/url.js","../node_modules/remark-parse/lib/locate/url.js","../node_modules/remark-parse/lib/tokenize/html-inline.js","../node_modules/remark-parse/lib/tokenize/link.js","../node_modules/remark-parse/lib/tokenize/reference.js","../node_modules/remark-parse/lib/tokenize/strong.js","../node_modules/remark-parse/lib/locate/strong.js","../node_modules/remark-parse/lib/tokenize/emphasis.js","../node_modules/remark-parse/lib/locate/emphasis.js","../node_modules/remark-parse/lib/tokenize/delete.js","../node_modules/remark-parse/lib/locate/delete.js","../node_modules/remark-parse/lib/tokenize/code-inline.js","../node_modules/remark-parse/lib/locate/code-inline.js","../node_modules/remark-parse/lib/tokenize/break.js","../node_modules/remark-parse/lib/locate/break.js","../node_modules/remark-parse/lib/tokenize/text.js"],"names":["module","exports","interruptors","tokenizers","ctx","params","interruptor","config","fn","offset","bool","ignore","bools","count","length","index","undefined","options","apply","collapseWhiteSpace","value","toLowerCase","position","gfm","commonmark","footnotes","pedantic","blocks","size","indent","character","charAt","stops","characters","Math","floor","openTag","closeTag","openCloseTag","RegExp","tag","fromIndex","indexOf","link","image","unherit","xtend","Parser","parse","Local","prototype","this","data","toggle","vfileLocation","unescape","decode","tokenizer","doc","file","setOptions","inList","inBlock","inLink","atStart","toOffset","proto","keys","key","result","push","exitStart","enterList","enterLink","enterBlock","interruptParagraph","interruptList","interruptBlockquote","blockTokenizers","newline","indentedCode","fencedCode","blockquote","atxHeading","thematicBreak","list","setextHeading","html","footnote","definition","table","paragraph","inlineTokenizers","escape","autoLink","url","reference","strong","emphasis","deletion","code","break","text","blockMethods","inlineMethods","tokenizeBlock","tokenizeInline","tokenizeFactory","prev","queue","slice","join","entities","decoder","raw","normalize","warning","handleWarning","offsets","line","start","reason","message","handler","textContext","referenceContext","type","location","method","name","matched","valueLength","self","tokens","methods","column","eat","now","updatePosition","onlyAtStart","notInList","notInBlock","notInLink","fail","Error","eof","subvalue","lastIndex","pos","Position","end","indentation","last","getOffset","before","node","combined","n","l","concat","current","substring","validateEat","reset","test","parent","children","MERGEABLE_NODES","mergeable","call","add","arguments","escapes","defaults","removePosition","String","content","replace","EXPRESSION_LINE_BREAKS","charCodeAt","whitespace","silent","repeat","trim","blankQueue","subvalueQueue","contentQueue","CODE_INDENT","lang","fenceCount","marker","flag","exdentedContent","closing","exdentedClosing","settings","interrupt","rest","nextIndex","startIndex","prefixed","exit","currentLine","values","contents","indents","depth","markerCount","decimal","getIndent","removeIndent","markers","ordered","currentMarker","prevEmpty","empty","items","allLines","emptyLines","item","enterTop","exitBlockquote","isLoose","indented","interuptors","LIST_ORDERED_COMMONMARK_MARKERS","LIST_ORDERED_MARKERS","LIST_UNORDERED_MARKERS","parseInt","TAB_SIZE","trail","loose","listItem","EXPRESSION_LOOSE_LIST_ITEM","EXPRESSION_TASK_ITEM","EXPRESSION_BULLET","EXPRESSION_PEDANTIC_BULLET","EXPRESSION_INITIAL_INDENT","task","pedanticListItem","normalListItem","checked","match","replacer","$0","max","bullet","lines","trimmedLines","$1","$2","$3","$4","Number","split","maximum","padding","minIndent","Infinity","matrix","unshift","shift","SETEXT_MARKERS","next","sequence","sequences","source","footnoteDefinition","EXPRESSION_INITIAL_TAB","subqueue","identifier","C_BRACKET_OPEN","beforeURL","beforeTitle","title","isEnclosedURLCharacter","delimiter","isUnclosedURLCharacter","nonTerminated","alignments","alignment","row","hasDash","align","cell","preamble","opening","lineCount","rows","lineIndex","pipeIndex","first","splice","trimTrailingLines","left","locate","locator","MAILTO_LENGTH","hasAtCharacter","substr","PROTOCOLS","PROTOCOLS_LENGTH","protocol","parenCount","nextCharacter","min","alphabetical","inlineHTML","EXPRESSION_HTML_LINK_OPEN","EXPRESSION_HTML_LINK_CLOSE","own","hasOwnProperty","LINK_MARKERS","COMMONMARK_LINK_MARKERS","closed","hasMarker","isImage","alt","bracketed","intro","referenceType","asterisk","underscore","word","strikethrough","previous","preceding","inlineCode","openingCount","found","tickQueue","hardBreak"],"mappings":"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","file":"static/js/vendors-remark.29e3a879.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = interrupt;\n\nfunction interrupt(interruptors, tokenizers, ctx, params) {\n  var bools = ['pedantic', 'commonmark'];\n  var count = bools.length;\n  var length = interruptors.length;\n  var index = -1;\n  var interruptor;\n  var config;\n  var fn;\n  var offset;\n  var bool;\n  var ignore;\n\n  while (++index < length) {\n    interruptor = interruptors[index];\n    config = interruptor[1] || {};\n    fn = interruptor[0];\n    offset = -1;\n    ignore = false;\n\n    while (++offset < count) {\n      bool = bools[offset];\n\n      if (config[bool] !== undefined && config[bool] !== ctx.options[bool]) {\n        ignore = true;\n        break;\n      }\n    }\n\n    if (ignore) {\n      continue;\n    }\n\n    if (tokenizers[fn].apply(ctx, params)) {\n      return true;\n    }\n  }\n\n  return false;\n}","'use strict';\n\nvar collapseWhiteSpace = require('collapse-white-space');\n\nmodule.exports = normalize;\n/* Normalize an identifier.  Collapses multiple white space\n * characters into a single space, and removes casing. */\n\nfunction normalize(value) {\n  return collapseWhiteSpace(value).toLowerCase();\n}","'use strict';\n\nmodule.exports = {\n  position: true,\n  gfm: true,\n  commonmark: false,\n  footnotes: false,\n  pedantic: false,\n  blocks: require('./block-elements.json')\n};","'use strict';\n\nmodule.exports = indentation;\n/* Map of characters, and their column length,\n * which can be used as indentation. */\n\nvar characters = {\n  ' ': 1,\n  '\\t': 4\n};\n/* Gets indentation information for a line. */\n\nfunction indentation(value) {\n  var index = 0;\n  var indent = 0;\n  var character = value.charAt(index);\n  var stops = {};\n  var size;\n\n  while (character in characters) {\n    size = characters[character];\n    indent += size;\n\n    if (size > 1) {\n      indent = Math.floor(indent / size) * size;\n    }\n\n    stops[indent] = index;\n    character = value.charAt(++index);\n  }\n\n  return {\n    indent: indent,\n    stops: stops\n  };\n}","'use strict';\n\nvar attributeName = '[a-zA-Z_:][a-zA-Z0-9:._-]*';\nvar unquoted = \"[^\\\"'=<>`\\\\u0000-\\\\u0020]+\";\nvar singleQuoted = '\\'[^\\']*\\'';\nvar doubleQuoted = '\"[^\"]*\"';\nvar attributeValue = '(?:' + unquoted + '|' + singleQuoted + '|' + doubleQuoted + ')';\nvar attribute = '(?:\\\\s+' + attributeName + '(?:\\\\s*=\\\\s*' + attributeValue + ')?)';\nvar openTag = '<[A-Za-z][A-Za-z0-9\\\\-]*' + attribute + '*\\\\s*\\\\/?>';\nvar closeTag = '<\\\\/[A-Za-z][A-Za-z0-9\\\\-]*\\\\s*>';\nvar comment = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';\nvar processing = '<[?].*?[?]>';\nvar declaration = '<![A-Za-z]+\\\\s+[^>]*>';\nvar cdata = '<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>';\nexports.openCloseTag = new RegExp('^(?:' + openTag + '|' + closeTag + ')');\nexports.tag = new RegExp('^(?:' + openTag + '|' + closeTag + '|' + comment + '|' + processing + '|' + declaration + '|' + cdata + ')');","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('<', fromIndex);\n}","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var link = value.indexOf('[', fromIndex);\n  var image = value.indexOf('![', fromIndex);\n\n  if (image === -1) {\n    return link;\n  }\n  /* Link can never be `-1` if an image is found, so we don’t need\n   * to check for that :) */\n\n\n  return link < image ? link : image;\n}","'use strict';\n\nvar unherit = require('unherit');\n\nvar xtend = require('xtend');\n\nvar Parser = require('./lib/parser.js');\n\nmodule.exports = parse;\nparse.Parser = Parser;\n\nfunction parse(options) {\n  var Local = unherit(Parser);\n  Local.prototype.options = xtend(Local.prototype.options, this.data('settings'), options);\n  this.Parser = Local;\n}","'use strict';\n\nvar xtend = require('xtend');\n\nvar toggle = require('state-toggle');\n\nvar vfileLocation = require('vfile-location');\n\nvar unescape = require('./unescape');\n\nvar decode = require('./decode');\n\nvar tokenizer = require('./tokenizer');\n\nmodule.exports = Parser;\n\nfunction Parser(doc, file) {\n  this.file = file;\n  this.offset = {};\n  this.options = xtend(this.options);\n  this.setOptions({});\n  this.inList = false;\n  this.inBlock = false;\n  this.inLink = false;\n  this.atStart = true;\n  this.toOffset = vfileLocation(file).toOffset;\n  this.unescape = unescape(this, 'escape');\n  this.decode = decode(this);\n}\n\nvar proto = Parser.prototype;\n/* Expose core. */\n\nproto.setOptions = require('./set-options');\nproto.parse = require('./parse');\n/* Expose `defaults`. */\n\nproto.options = require('./defaults');\n/* Enter and exit helpers. */\n\nproto.exitStart = toggle('atStart', true);\nproto.enterList = toggle('inList', false);\nproto.enterLink = toggle('inLink', false);\nproto.enterBlock = toggle('inBlock', false);\n/* Nodes that can interupt a paragraph:\n *\n * ```markdown\n * A paragraph, followed by a thematic break.\n * ___\n * ```\n *\n * In the above example, the thematic break “interupts”\n * the paragraph. */\n\nproto.interruptParagraph = [['thematicBreak'], ['atxHeading'], ['fencedCode'], ['blockquote'], ['html'], ['setextHeading', {\n  commonmark: false\n}], ['definition', {\n  commonmark: false\n}], ['footnote', {\n  commonmark: false\n}]];\n/* Nodes that can interupt a list:\n *\n * ```markdown\n * - One\n * ___\n * ```\n *\n * In the above example, the thematic break “interupts”\n * the list. */\n\nproto.interruptList = [['atxHeading', {\n  pedantic: false\n}], ['fencedCode', {\n  pedantic: false\n}], ['thematicBreak', {\n  pedantic: false\n}], ['definition', {\n  commonmark: false\n}], ['footnote', {\n  commonmark: false\n}]];\n/* Nodes that can interupt a blockquote:\n *\n * ```markdown\n * > A paragraph.\n * ___\n * ```\n *\n * In the above example, the thematic break “interupts”\n * the blockquote. */\n\nproto.interruptBlockquote = [['indentedCode', {\n  commonmark: true\n}], ['fencedCode', {\n  commonmark: true\n}], ['atxHeading', {\n  commonmark: true\n}], ['setextHeading', {\n  commonmark: true\n}], ['thematicBreak', {\n  commonmark: true\n}], ['html', {\n  commonmark: true\n}], ['list', {\n  commonmark: true\n}], ['definition', {\n  commonmark: false\n}], ['footnote', {\n  commonmark: false\n}]];\n/* Handlers. */\n\nproto.blockTokenizers = {\n  newline: require('./tokenize/newline'),\n  indentedCode: require('./tokenize/code-indented'),\n  fencedCode: require('./tokenize/code-fenced'),\n  blockquote: require('./tokenize/blockquote'),\n  atxHeading: require('./tokenize/heading-atx'),\n  thematicBreak: require('./tokenize/thematic-break'),\n  list: require('./tokenize/list'),\n  setextHeading: require('./tokenize/heading-setext'),\n  html: require('./tokenize/html-block'),\n  footnote: require('./tokenize/footnote-definition'),\n  definition: require('./tokenize/definition'),\n  table: require('./tokenize/table'),\n  paragraph: require('./tokenize/paragraph')\n};\nproto.inlineTokenizers = {\n  escape: require('./tokenize/escape'),\n  autoLink: require('./tokenize/auto-link'),\n  url: require('./tokenize/url'),\n  html: require('./tokenize/html-inline'),\n  link: require('./tokenize/link'),\n  reference: require('./tokenize/reference'),\n  strong: require('./tokenize/strong'),\n  emphasis: require('./tokenize/emphasis'),\n  deletion: require('./tokenize/delete'),\n  code: require('./tokenize/code-inline'),\n  break: require('./tokenize/break'),\n  text: require('./tokenize/text')\n};\n/* Expose precedence. */\n\nproto.blockMethods = keys(proto.blockTokenizers);\nproto.inlineMethods = keys(proto.inlineTokenizers);\n/* Tokenizers. */\n\nproto.tokenizeBlock = tokenizer('block');\nproto.tokenizeInline = tokenizer('inline');\nproto.tokenizeFactory = tokenizer;\n/* Get all keys in `value`. */\n\nfunction keys(value) {\n  var result = [];\n  var key;\n\n  for (key in value) {\n    result.push(key);\n  }\n\n  return result;\n}","'use strict';\n\nmodule.exports = factory;\n/* Factory to de-escape a value, based on a list at `key`\n * in `ctx`. */\n\nfunction factory(ctx, key) {\n  return unescape;\n  /* De-escape a string using the expression at `key`\n   * in `ctx`. */\n\n  function unescape(value) {\n    var prev = 0;\n    var index = value.indexOf('\\\\');\n    var escape = ctx[key];\n    var queue = [];\n    var character;\n\n    while (index !== -1) {\n      queue.push(value.slice(prev, index));\n      prev = index + 1;\n      character = value.charAt(prev);\n      /* If the following character is not a valid escape,\n       * add the slash. */\n\n      if (!character || escape.indexOf(character) === -1) {\n        queue.push('\\\\');\n      }\n\n      index = value.indexOf('\\\\', prev);\n    }\n\n    queue.push(value.slice(prev));\n    return queue.join('');\n  }\n}","'use strict';\n\nvar xtend = require('xtend');\n\nvar entities = require('parse-entities');\n\nmodule.exports = factory;\n/* Factory to create an entity decoder. */\n\nfunction factory(ctx) {\n  decoder.raw = decodeRaw;\n  return decoder;\n  /* Normalize `position` to add an `indent`. */\n\n  function normalize(position) {\n    var offsets = ctx.offset;\n    var line = position.line;\n    var result = [];\n\n    while (++line) {\n      if (!(line in offsets)) {\n        break;\n      }\n\n      result.push((offsets[line] || 0) + 1);\n    }\n\n    return {\n      start: position,\n      indent: result\n    };\n  }\n  /* Handle a warning.\n   * See https://github.com/wooorm/parse-entities\n   * for the warnings. */\n\n\n  function handleWarning(reason, position, code) {\n    if (code === 3) {\n      return;\n    }\n\n    ctx.file.message(reason, position);\n  }\n  /* Decode `value` (at `position`) into text-nodes. */\n\n\n  function decoder(value, position, handler) {\n    entities(value, {\n      position: normalize(position),\n      warning: handleWarning,\n      text: handler,\n      reference: handler,\n      textContext: ctx,\n      referenceContext: ctx\n    });\n  }\n  /* Decode `value` (at `position`) into a string. */\n\n\n  function decodeRaw(value, position, options) {\n    return entities(value, xtend(options, {\n      position: normalize(position),\n      warning: handleWarning\n    }));\n  }\n}","'use strict';\n\nmodule.exports = factory;\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n/* Check whether a node is mergeable with adjacent nodes. */\n\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n\n  return start.line !== end.line || end.column - start.column === node.value.length;\n}\n/* Merge two text nodes: `node` into `prev`. */\n\n\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n  return prev;\n}\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\n\n\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n  return prev;\n}\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\n\n\nfunction factory(type) {\n  return tokenize;\n  /* Tokenizer for a bound `type`. */\n\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n    /* Trim white space only lines. */\n\n    if (!value) {\n      return tokens;\n    }\n    /* Expose on `eat`. */\n\n\n    eat.now = now;\n    eat.file = self.file;\n    /* Sync initial offset. */\n\n    updatePosition('');\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (method && (\n        /* istanbul ignore next */\n        !method.onlyAtStart || self.atStart) && (!method.notInList || !self.inList) && (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {\n          valueLength = value.length;\n          method.apply(self, [eat, value]);\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n      /* istanbul ignore if */\n\n\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n    return tokens;\n    /* Update line, column, and offset based on\n     * `value`. */\n\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n\n\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n    /* Get the current position. */\n\n\n    function now() {\n      var pos = {\n        line: line,\n        column: column\n      };\n      pos.offset = self.toOffset(pos);\n      return pos;\n    }\n    /* Store position information for a node. */\n\n\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n\n\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(new Error('Incorrectly eaten value: please report this ' + 'warning on http://git.io/vg5Ft'), now());\n      }\n    }\n    /* Mark position and patch `node.position`. */\n\n\n    function position() {\n      var before = now();\n      return update;\n      /* Add the position to a node. */\n\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n        node.position = new Position(start);\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n        return node;\n      }\n    }\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n\n\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (prev && node.type === prev.type && node.type in MERGEABLE_NODES && mergeable(prev) && mergeable(node)) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n\n\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n      validateEat(subvalue);\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n      value = value.substring(subvalue.length);\n      updatePosition(subvalue);\n      indent = indent();\n      return apply;\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n\n\n      function reset() {\n        var node = apply.apply(null, arguments);\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return node;\n      }\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n\n\n      function test() {\n        var result = pos({});\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return result.position;\n      }\n    }\n  }\n}","'use strict';\n\nvar xtend = require('xtend');\n\nvar escapes = require('markdown-escapes');\n\nvar defaults = require('./defaults');\n\nmodule.exports = setOptions;\n\nfunction setOptions(options) {\n  var self = this;\n  var current = self.options;\n  var key;\n  var value;\n\n  if (options == null) {\n    options = {};\n  } else if (typeof options === 'object') {\n    options = xtend(options);\n  } else {\n    throw new Error('Invalid value `' + options + '` ' + 'for setting `options`');\n  }\n\n  for (key in defaults) {\n    value = options[key];\n\n    if (value == null) {\n      value = current[key];\n    }\n\n    if (key !== 'blocks' && typeof value !== 'boolean' || key === 'blocks' && typeof value !== 'object') {\n      throw new Error('Invalid value `' + value + '` for setting `options.' + key + '`');\n    }\n\n    options[key] = value;\n  }\n\n  self.options = options;\n  self.escape = escapes(options);\n  return self;\n}","'use strict';\n\nvar xtend = require('xtend');\n\nvar removePosition = require('unist-util-remove-position');\n\nmodule.exports = parse;\nvar C_NEWLINE = '\\n';\nvar EXPRESSION_LINE_BREAKS = /\\r\\n|\\r/g;\n/* Parse the bound file. */\n\nfunction parse() {\n  var self = this;\n  var value = String(self.file);\n  var start = {\n    line: 1,\n    column: 1,\n    offset: 0\n  };\n  var content = xtend(start);\n  var node;\n  /* Clean non-unix newlines: `\\r\\n` and `\\r` are all\n   * changed to `\\n`.  This should not affect positional\n   * information. */\n\n  value = value.replace(EXPRESSION_LINE_BREAKS, C_NEWLINE);\n\n  if (value.charCodeAt(0) === 0xFEFF) {\n    value = value.slice(1);\n    content.column++;\n    content.offset++;\n  }\n\n  node = {\n    type: 'root',\n    children: self.tokenizeBlock(value, content),\n    position: {\n      start: start,\n      end: self.eof || xtend(start)\n    }\n  };\n\n  if (!self.options.position) {\n    removePosition(node, true);\n  }\n\n  return node;\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = newline;\n/* Tokenise newline. */\n\nfunction newline(eat, value, silent) {\n  var character = value.charAt(0);\n  var length;\n  var subvalue;\n  var queue;\n  var index;\n\n  if (character !== '\\n') {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  index = 1;\n  length = value.length;\n  subvalue = character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n\n    if (character === '\\n') {\n      subvalue += queue;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  eat(subvalue);\n}","'use strict';\n\nvar repeat = require('repeat-string');\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = indentedCode;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar CODE_INDENT_COUNT = 4;\nvar CODE_INDENT = repeat(C_SPACE, CODE_INDENT_COUNT);\n/* Tokenise indented code. */\n\nfunction indentedCode(eat, value, silent) {\n  var index = -1;\n  var length = value.length;\n  var subvalue = '';\n  var content = '';\n  var subvalueQueue = '';\n  var contentQueue = '';\n  var character;\n  var blankQueue;\n  var indent;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (indent) {\n      indent = false;\n      subvalue += subvalueQueue;\n      content += contentQueue;\n      subvalueQueue = '';\n      contentQueue = '';\n\n      if (character === C_NEWLINE) {\n        subvalueQueue = character;\n        contentQueue = character;\n      } else {\n        subvalue += character;\n        content += character;\n\n        while (++index < length) {\n          character = value.charAt(index);\n\n          if (!character || character === C_NEWLINE) {\n            contentQueue = character;\n            subvalueQueue = character;\n            break;\n          }\n\n          subvalue += character;\n          content += character;\n        }\n      }\n    } else if (character === C_SPACE && value.charAt(index + 1) === character && value.charAt(index + 2) === character && value.charAt(index + 3) === character) {\n      subvalueQueue += CODE_INDENT;\n      index += 3;\n      indent = true;\n    } else if (character === C_TAB) {\n      subvalueQueue += character;\n      indent = true;\n    } else {\n      blankQueue = '';\n\n      while (character === C_TAB || character === C_SPACE) {\n        blankQueue += character;\n        character = value.charAt(++index);\n      }\n\n      if (character !== C_NEWLINE) {\n        break;\n      }\n\n      subvalueQueue += blankQueue + character;\n      contentQueue += character;\n    }\n  }\n\n  if (content) {\n    if (silent) {\n      return true;\n    }\n\n    return eat(subvalue)({\n      type: 'code',\n      lang: null,\n      value: trim(content)\n    });\n  }\n}","'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n  /* Eat initial spacing. */\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n  /* Eat the fence. */\n\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n  /* Eat spacing before flag. */\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n  /* Eat flag. */\n\n\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE || character === C_TILDE || character === C_TICK) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n  /* Eat content. */\n\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n\n\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}","'use strict';\n\nvar trim = require('trim');\n\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = blockquote;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_GT = '>';\n/* Tokenise a blockquote. */\n\nfunction blockquote(eat, value, silent) {\n  var self = this;\n  var offsets = self.offset;\n  var tokenizers = self.blockTokenizers;\n  var interruptors = self.interruptBlockquote;\n  var now = eat.now();\n  var currentLine = now.line;\n  var length = value.length;\n  var values = [];\n  var contents = [];\n  var indents = [];\n  var add;\n  var index = 0;\n  var character;\n  var rest;\n  var nextIndex;\n  var content;\n  var line;\n  var startIndex;\n  var prefixed;\n  var exit;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (value.charAt(index) !== C_GT) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      index++;\n    }\n\n    if (value.charAt(index) === C_GT) {\n      index++;\n      prefixed = true;\n\n      if (value.charAt(index) === C_SPACE) {\n        index++;\n      }\n    } else {\n      index = startIndex;\n    }\n\n    content = value.slice(index, nextIndex);\n\n    if (!prefixed && !trim(content)) {\n      index = startIndex;\n      break;\n    }\n\n    if (!prefixed) {\n      rest = value.slice(index);\n      /* Check if the following code contains a possible\n       * block. */\n\n      if (interrupt(interruptors, tokenizers, self, [eat, rest, true])) {\n        break;\n      }\n    }\n\n    line = startIndex === index ? content : value.slice(startIndex, nextIndex);\n    indents.push(index - startIndex);\n    values.push(line);\n    contents.push(content);\n    index = nextIndex + 1;\n  }\n\n  index = -1;\n  length = indents.length;\n  add = eat(values.join(C_NEWLINE));\n\n  while (++index < length) {\n    offsets[currentLine] = (offsets[currentLine] || 0) + indents[index];\n    currentLine++;\n  }\n\n  exit = self.enterBlock();\n  contents = self.tokenizeBlock(contents.join(C_NEWLINE), now);\n  exit();\n  return add({\n    type: 'blockquote',\n    children: contents\n  });\n}","'use strict';\n\nmodule.exports = atxHeading;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_HASH = '#';\nvar MAX_ATX_COUNT = 6;\n\nfunction atxHeading(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = -1;\n  var now = eat.now();\n  var subvalue = '';\n  var content = '';\n  var character;\n  var queue;\n  var depth;\n  /* Eat initial spacing. */\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  }\n  /* Eat hashes. */\n\n\n  depth = 0;\n\n  while (++index <= length) {\n    character = value.charAt(index);\n\n    if (character !== C_HASH) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n    depth++;\n  }\n\n  if (depth > MAX_ATX_COUNT) {\n    return;\n  }\n\n  if (!depth || !settings.pedantic && value.charAt(index + 1) === C_HASH) {\n    return;\n  }\n\n  length = value.length + 1;\n  /* Eat intermediate white-space. */\n\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      index--;\n      break;\n    }\n\n    queue += character;\n  }\n  /* Exit when not in pedantic mode without spacing. */\n\n\n  if (!settings.pedantic && queue.length === 0 && character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n  /* Eat content. */\n\n\n  subvalue += queue;\n  queue = '';\n  content = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n\n    if (character !== C_SPACE && character !== C_TAB && character !== C_HASH) {\n      content += queue + character;\n      queue = '';\n      continue;\n    }\n\n    while (character === C_SPACE || character === C_TAB) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    while (character === C_HASH) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    while (character === C_SPACE || character === C_TAB) {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    index--;\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue;\n  return eat(subvalue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}","'use strict';\n\nmodule.exports = thematicBreak;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_DASH = '-';\nvar THEMATIC_BREAK_MARKER_COUNT = 3;\n\nfunction thematicBreak(eat, value, silent) {\n  var index = -1;\n  var length = value.length + 1;\n  var subvalue = '';\n  var character;\n  var marker;\n  var markerCount;\n  var queue;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    subvalue += character;\n  }\n\n  if (character !== C_ASTERISK && character !== C_DASH && character !== C_UNDERSCORE) {\n    return;\n  }\n\n  marker = character;\n  subvalue += character;\n  markerCount = 1;\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === marker) {\n      markerCount++;\n      subvalue += queue + marker;\n      queue = '';\n    } else if (character === C_SPACE) {\n      queue += character;\n    } else if (markerCount >= THEMATIC_BREAK_MARKER_COUNT && (!character || character === C_NEWLINE)) {\n      subvalue += queue;\n\n      if (silent) {\n        return true;\n      }\n\n      return eat(subvalue)({\n        type: 'thematicBreak'\n      });\n    } else {\n      return;\n    }\n  }\n}","'use strict';\n/* eslint-disable max-params */\n\nvar trim = require('trim');\n\nvar repeat = require('repeat-string');\n\nvar decimal = require('is-decimal');\n\nvar getIndent = require('../util/get-indentation');\n\nvar removeIndent = require('../util/remove-indentation');\n\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n/* Map of characters which can be used to mark\n * list-items. */\n\nvar LIST_UNORDERED_MARKERS = {};\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n/* Map of characters which can be used to mark\n * list-items after a digit. */\n\nvar LIST_ORDERED_MARKERS = {};\nLIST_ORDERED_MARKERS[C_DOT] = true;\n/* Map of characters which can be used to mark\n * list-items after a digit. */\n\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - size % TAB_SIZE;\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n  markers = commonmark ? LIST_ORDERED_COMMONMARK_MARKERS : LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - size % TAB_SIZE;\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - size % TAB_SIZE;\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (currentMarker === C_ASTERISK || currentMarker === C_UNDERSCORE || currentMarker === C_DASH) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n  node.loose = isLoose;\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) || value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n/* Create a list-item using overly simple mechanics. */\n\n\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  /* Remove the list-item’s bullet. */\n\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n\n  line = position.line;\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n    return '';\n  }\n}\n/* Create a list-item using sane mechanics. */\n\n\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n  /* Remove the list-item’s bullet. */\n\n  value = value.replace(EXPRESSION_BULLET, replacer);\n  lines = value.split(C_NEWLINE);\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n\n  trimmedLines[0] = rest;\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n    return max + rest;\n  }\n}","'use strict';\n\nvar trim = require('trim');\n\nvar repeat = require('repeat-string');\n\nvar getIndent = require('./get-indentation');\n\nmodule.exports = indentation;\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n/* Remove the minimum indent from every line in `value`.\n * Supports both tab, spaced, and mixed indentation (as\n * well as possible). */\n\nfunction indentation(value, maximum) {\n  var values = value.split(C_NEWLINE);\n  var position = values.length + 1;\n  var minIndent = Infinity;\n  var matrix = [];\n  var index;\n  var indentation;\n  var stops;\n  var padding;\n  values.unshift(repeat(C_SPACE, maximum) + '!');\n\n  while (position--) {\n    indentation = getIndent(values[position]);\n    matrix[position] = indentation.stops;\n\n    if (trim(values[position]).length === 0) {\n      continue;\n    }\n\n    if (indentation.indent) {\n      if (indentation.indent > 0 && indentation.indent < minIndent) {\n        minIndent = indentation.indent;\n      }\n    } else {\n      minIndent = Infinity;\n      break;\n    }\n  }\n\n  if (minIndent !== Infinity) {\n    position = values.length;\n\n    while (position--) {\n      stops = matrix[position];\n      index = minIndent;\n\n      while (index && !(index in stops)) {\n        index--;\n      }\n\n      if (trim(values[position]).length !== 0 && minIndent && index !== minIndent) {\n        padding = C_TAB;\n      } else {\n        padding = '';\n      }\n\n      values[position] = padding + values[position].slice(index in stops ? stops[index] + 1 : 0);\n    }\n  }\n\n  values.shift();\n  return values.join(C_NEWLINE);\n}","'use strict';\n\nmodule.exports = setextHeading;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_EQUALS = '=';\nvar C_DASH = '-';\nvar MAX_HEADING_INDENT = 3;\n/* Map of characters which can be used to mark setext\n * headers, mapping to their corresponding depth. */\n\nvar SETEXT_MARKERS = {};\nSETEXT_MARKERS[C_EQUALS] = 1;\nSETEXT_MARKERS[C_DASH] = 2;\n\nfunction setextHeading(eat, value, silent) {\n  var self = this;\n  var now = eat.now();\n  var length = value.length;\n  var index = -1;\n  var subvalue = '';\n  var content;\n  var queue;\n  var character;\n  var marker;\n  var depth;\n  /* Eat initial indentation. */\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE || index >= MAX_HEADING_INDENT) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  }\n  /* Eat content. */\n\n\n  content = '';\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE) {\n      index--;\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      content += queue + character;\n      queue = '';\n    }\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue;\n  /* Ensure the content is followed by a newline and a\n   * valid marker. */\n\n  character = value.charAt(++index);\n  marker = value.charAt(++index);\n\n  if (character !== C_NEWLINE || !SETEXT_MARKERS[marker]) {\n    return;\n  }\n\n  subvalue += character;\n  /* Eat Setext-line. */\n\n  queue = marker;\n  depth = SETEXT_MARKERS[marker];\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      if (character !== C_NEWLINE) {\n        return;\n      }\n\n      index--;\n      break;\n    }\n\n    queue += character;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  return eat(subvalue + queue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}","'use strict';\n\nvar openCloseTag = require('../util/html').openCloseTag;\n\nmodule.exports = blockHTML;\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_LT = '<';\n\nfunction blockHTML(eat, value, silent) {\n  var self = this;\n  var blocks = self.options.blocks;\n  var length = value.length;\n  var index = 0;\n  var next;\n  var line;\n  var offset;\n  var character;\n  var count;\n  var sequence;\n  var subvalue;\n  var sequences = [[/^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\\?/, /\\?>/, true], [/^<![A-Za-z]/, />/, true], [/^<!\\[CDATA\\[/, /\\]\\]>/, true], [new RegExp('^</?(' + blocks.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(openCloseTag.source + '\\\\s*$'), /^$/, false]];\n  /* Eat initial spacing. */\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (value.charAt(index) !== C_LT) {\n    return;\n  }\n\n  next = value.indexOf(C_NEWLINE, index + 1);\n  next = next === -1 ? length : next;\n  line = value.slice(index, next);\n  offset = -1;\n  count = sequences.length;\n\n  while (++offset < count) {\n    if (sequences[offset][0].test(line)) {\n      sequence = sequences[offset];\n      break;\n    }\n  }\n\n  if (!sequence) {\n    return;\n  }\n\n  if (silent) {\n    return sequence[2];\n  }\n\n  index = next;\n\n  if (!sequence[1].test(line)) {\n    while (index < length) {\n      next = value.indexOf(C_NEWLINE, index + 1);\n      next = next === -1 ? length : next;\n      line = value.slice(index + 1, next);\n\n      if (sequence[1].test(line)) {\n        if (line) {\n          index = next;\n        }\n\n        break;\n      }\n\n      index = next;\n    }\n  }\n\n  subvalue = value.slice(0, index);\n  return eat(subvalue)({\n    type: 'html',\n    value: subvalue\n  });\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar normalize = require('../util/normalize');\n\nmodule.exports = footnoteDefinition;\nfootnoteDefinition.notInList = true;\nfootnoteDefinition.notInBlock = true;\nvar C_BACKSLASH = '\\\\';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_CARET = '^';\nvar C_COLON = ':';\nvar EXPRESSION_INITIAL_TAB = /^( {4}|\\t)?/gm;\n\nfunction footnoteDefinition(eat, value, silent) {\n  var self = this;\n  var offsets = self.offset;\n  var index;\n  var length;\n  var subvalue;\n  var now;\n  var currentLine;\n  var content;\n  var queue;\n  var subqueue;\n  var character;\n  var identifier;\n  var add;\n  var exit;\n\n  if (!self.options.footnotes) {\n    return;\n  }\n\n  index = 0;\n  length = value.length;\n  subvalue = '';\n  now = eat.now();\n  currentLine = now.line;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  if (value.charAt(index) !== C_BRACKET_OPEN || value.charAt(index + 1) !== C_CARET) {\n    return;\n  }\n\n  subvalue += C_BRACKET_OPEN + C_CARET;\n  index = subvalue.length;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      break;\n    } else if (character === C_BACKSLASH) {\n      queue += character;\n      index++;\n      character = value.charAt(index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (!queue || value.charAt(index) !== C_BRACKET_CLOSE || value.charAt(index + 1) !== C_COLON) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  identifier = normalize(queue);\n  subvalue += queue + C_BRACKET_CLOSE + C_COLON;\n  index = subvalue.length;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  queue = '';\n  content = '';\n  subqueue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE) {\n      subqueue = character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_NEWLINE) {\n          break;\n        }\n\n        subqueue += character;\n        index++;\n      }\n\n      queue += subqueue;\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character !== C_SPACE) {\n          break;\n        }\n\n        subqueue += character;\n        index++;\n      }\n\n      if (subqueue.length === 0) {\n        break;\n      }\n\n      queue += subqueue;\n    }\n\n    if (queue) {\n      content += queue;\n      queue = '';\n    }\n\n    content += character;\n    index++;\n  }\n\n  subvalue += content;\n  content = content.replace(EXPRESSION_INITIAL_TAB, function (line) {\n    offsets[currentLine] = (offsets[currentLine] || 0) + line.length;\n    currentLine++;\n    return '';\n  });\n  add = eat(subvalue);\n  exit = self.enterBlock();\n  content = self.tokenizeBlock(content, now);\n  exit();\n  return add({\n    type: 'footnoteDefinition',\n    identifier: identifier,\n    children: content\n  });\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar normalize = require('../util/normalize');\n\nmodule.exports = definition;\ndefinition.notInList = true;\ndefinition.notInBlock = true;\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\nvar C_BACKSLASH = '\\\\';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_COLON = ':';\nvar C_LT = '<';\nvar C_GT = '>';\n\nfunction definition(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var beforeURL;\n  var beforeTitle;\n  var queue;\n  var character;\n  var test;\n  var identifier;\n  var url;\n  var title;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      break;\n    } else if (character === C_BACKSLASH) {\n      queue += character;\n      index++;\n      character = value.charAt(index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (!queue || value.charAt(index) !== C_BRACKET_CLOSE || value.charAt(index + 1) !== C_COLON) {\n    return;\n  }\n\n  identifier = queue;\n  subvalue += queue + C_BRACKET_CLOSE + C_COLON;\n  index = subvalue.length;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE && character !== C_NEWLINE) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!isEnclosedURLCharacter(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === isEnclosedURLCharacter.delimiter) {\n      subvalue += C_LT + queue + character;\n      index++;\n    } else {\n      if (commonmark) {\n        return;\n      }\n\n      index -= queue.length + 1;\n      queue = '';\n    }\n  }\n\n  if (!queue) {\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!isUnclosedURLCharacter(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    subvalue += queue;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  url = queue;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE && character !== C_NEWLINE) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  test = null;\n\n  if (character === C_DOUBLE_QUOTE) {\n    test = C_DOUBLE_QUOTE;\n  } else if (character === C_SINGLE_QUOTE) {\n    test = C_SINGLE_QUOTE;\n  } else if (character === C_PAREN_OPEN) {\n    test = C_PAREN_CLOSE;\n  }\n\n  if (!test) {\n    queue = '';\n    index = subvalue.length;\n  } else if (queue) {\n    subvalue += queue + character;\n    index = subvalue.length;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === test) {\n        break;\n      }\n\n      if (character === C_NEWLINE) {\n        index++;\n        character = value.charAt(index);\n\n        if (character === C_NEWLINE || character === test) {\n          return;\n        }\n\n        queue += C_NEWLINE;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character !== test) {\n      return;\n    }\n\n    beforeTitle = subvalue;\n    subvalue += queue + character;\n    index++;\n    title = queue;\n    queue = '';\n  } else {\n    return;\n  }\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (!character || character === C_NEWLINE) {\n    if (silent) {\n      return true;\n    }\n\n    beforeURL = eat(beforeURL).test().end;\n    url = self.decode.raw(self.unescape(url), beforeURL, {\n      nonTerminated: false\n    });\n\n    if (title) {\n      beforeTitle = eat(beforeTitle).test().end;\n      title = self.decode.raw(self.unescape(title), beforeTitle);\n    }\n\n    return eat(subvalue)({\n      type: 'definition',\n      identifier: normalize(identifier),\n      title: title || null,\n      url: url\n    });\n  }\n}\n/* Check if `character` can be inside an enclosed URI. */\n\n\nfunction isEnclosedURLCharacter(character) {\n  return character !== C_GT && character !== C_BRACKET_OPEN && character !== C_BRACKET_CLOSE;\n}\n\nisEnclosedURLCharacter.delimiter = C_GT;\n/* Check if `character` can be inside an unclosed URI. */\n\nfunction isUnclosedURLCharacter(character) {\n  return character !== C_BRACKET_OPEN && character !== C_BRACKET_CLOSE && !whitespace(character);\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n  /* Exit when not in gfm-mode. */\n\n  if (!self.options.gfm) {\n    return;\n  }\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n\n\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n  /* Parse the alignment row. */\n\n\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n  /* Exit when without enough columns. */\n\n\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n  /* Parse the rows. */\n\n\n  position = -1;\n  rows = [];\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {\n      type: 'tableRow',\n      children: []\n    };\n    /* Eat a newline character when this is not the\n     * first row. */\n\n    if (position) {\n      eat(C_NEWLINE);\n    }\n    /* Eat the row. */\n\n\n    eat(line).reset(row, table);\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n    /* Eat the alignment row. */\n\n\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}","'use strict';\n\nvar trim = require('trim');\n\nvar decimal = require('is-decimal');\n\nvar trimTrailingLines = require('trim-trailing-lines');\n\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = paragraph;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar TAB_SIZE = 4;\n/* Tokenise paragraph. */\n\nfunction paragraph(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var commonmark = settings.commonmark;\n  var gfm = settings.gfm;\n  var tokenizers = self.blockTokenizers;\n  var interruptors = self.interruptParagraph;\n  var index = value.indexOf(C_NEWLINE);\n  var length = value.length;\n  var position;\n  var subvalue;\n  var character;\n  var size;\n  var now;\n\n  while (index < length) {\n    /* Eat everything if there’s no following newline. */\n    if (index === -1) {\n      index = length;\n      break;\n    }\n    /* Stop if the next character is NEWLINE. */\n\n\n    if (value.charAt(index + 1) === C_NEWLINE) {\n      break;\n    }\n    /* In commonmark-mode, following indented lines\n     * are part of the paragraph. */\n\n\n    if (commonmark) {\n      size = 0;\n      position = index + 1;\n\n      while (position < length) {\n        character = value.charAt(position);\n\n        if (character === C_TAB) {\n          size = TAB_SIZE;\n          break;\n        } else if (character === C_SPACE) {\n          size++;\n        } else {\n          break;\n        }\n\n        position++;\n      }\n\n      if (size >= TAB_SIZE) {\n        index = value.indexOf(C_NEWLINE, index + 1);\n        continue;\n      }\n    }\n\n    subvalue = value.slice(index + 1);\n    /* Check if the following code contains a possible\n     * block. */\n\n    if (interrupt(interruptors, tokenizers, self, [eat, subvalue, true])) {\n      break;\n    }\n    /* Break if the following line starts a list, when\n     * already in a list, or when in commonmark, or when\n     * in gfm mode and the bullet is *not* numeric. */\n\n\n    if (tokenizers.list.call(self, eat, subvalue, true) && (self.inList || commonmark || gfm && !decimal(trim.left(subvalue).charAt(0)))) {\n      break;\n    }\n\n    position = index;\n    index = value.indexOf(C_NEWLINE, index + 1);\n\n    if (index !== -1 && trim(value.slice(position, index)) === '') {\n      index = position;\n      break;\n    }\n  }\n\n  subvalue = value.slice(0, index);\n\n  if (trim(subvalue) === '') {\n    eat(subvalue);\n    return null;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  subvalue = trimTrailingLines(subvalue);\n  return eat(subvalue)({\n    type: 'paragraph',\n    children: self.tokenizeInline(subvalue, now)\n  });\n}","'use strict';\n\nvar locate = require('../locate/escape');\n\nmodule.exports = escape;\nescape.locator = locate;\n\nfunction escape(eat, value, silent) {\n  var self = this;\n  var character;\n  var node;\n\n  if (value.charAt(0) === '\\\\') {\n    character = value.charAt(1);\n\n    if (self.escape.indexOf(character) !== -1) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true;\n      }\n\n      if (character === '\\n') {\n        node = {\n          type: 'break'\n        };\n      } else {\n        node = {\n          type: 'text',\n          value: character\n        };\n      }\n\n      return eat('\\\\' + character)(node);\n    }\n  }\n}","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('\\\\', fromIndex);\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar decode = require('parse-entities');\n\nvar locate = require('../locate/tag');\n\nmodule.exports = autoLink;\nautoLink.locator = locate;\nautoLink.notInLink = true;\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_AT_SIGN = '@';\nvar C_SLASH = '/';\nvar MAILTO = 'mailto:';\nvar MAILTO_LENGTH = MAILTO.length;\n/* Tokenise a link. */\n\nfunction autoLink(eat, value, silent) {\n  var self;\n  var subvalue;\n  var length;\n  var index;\n  var queue;\n  var character;\n  var hasAtCharacter;\n  var link;\n  var now;\n  var content;\n  var tokenizers;\n  var exit;\n\n  if (value.charAt(0) !== C_LT) {\n    return;\n  }\n\n  self = this;\n  subvalue = '';\n  length = value.length;\n  index = 0;\n  queue = '';\n  hasAtCharacter = false;\n  link = '';\n  index++;\n  subvalue = C_LT;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (whitespace(character) || character === C_GT || character === C_AT_SIGN || character === ':' && value.charAt(index + 1) === C_SLASH) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  link += queue;\n  queue = '';\n  character = value.charAt(index);\n  link += character;\n  index++;\n\n  if (character === C_AT_SIGN) {\n    hasAtCharacter = true;\n  } else {\n    if (character !== ':' || value.charAt(index + 1) !== C_SLASH) {\n      return;\n    }\n\n    link += C_SLASH;\n    index++;\n  }\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (whitespace(character) || character === C_GT) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (!queue || character !== C_GT) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  link += queue;\n  content = link;\n  subvalue += link + character;\n  now = eat.now();\n  now.column++;\n  now.offset++;\n\n  if (hasAtCharacter) {\n    if (link.slice(0, MAILTO_LENGTH).toLowerCase() === MAILTO) {\n      content = content.substr(MAILTO_LENGTH);\n      now.column += MAILTO_LENGTH;\n      now.offset += MAILTO_LENGTH;\n    } else {\n      link = MAILTO + link;\n    }\n  }\n  /* Temporarily remove all tokenizers except text in autolinks. */\n\n\n  tokenizers = self.inlineTokenizers;\n  self.inlineTokenizers = {\n    text: tokenizers.text\n  };\n  exit = self.enterLink();\n  content = self.tokenizeInline(content, now);\n  self.inlineTokenizers = tokenizers;\n  exit();\n  return eat(subvalue)({\n    type: 'link',\n    title: null,\n    url: decode(link, {\n      nonTerminated: false\n    }),\n    children: content\n  });\n}","'use strict';\n\nvar decode = require('parse-entities');\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/url');\n\nmodule.exports = url;\nurl.locator = locate;\nurl.notInLink = true;\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_AT_SIGN = '@';\nvar HTTP_PROTOCOL = 'http://';\nvar HTTPS_PROTOCOL = 'https://';\nvar MAILTO_PROTOCOL = 'mailto:';\nvar PROTOCOLS = [HTTP_PROTOCOL, HTTPS_PROTOCOL, MAILTO_PROTOCOL];\nvar PROTOCOLS_LENGTH = PROTOCOLS.length;\n\nfunction url(eat, value, silent) {\n  var self = this;\n  var subvalue;\n  var content;\n  var character;\n  var index;\n  var position;\n  var protocol;\n  var match;\n  var length;\n  var queue;\n  var parenCount;\n  var nextCharacter;\n  var exit;\n\n  if (!self.options.gfm) {\n    return;\n  }\n\n  subvalue = '';\n  index = -1;\n  length = PROTOCOLS_LENGTH;\n\n  while (++index < length) {\n    protocol = PROTOCOLS[index];\n    match = value.slice(0, protocol.length);\n\n    if (match.toLowerCase() === protocol) {\n      subvalue = match;\n      break;\n    }\n  }\n\n  if (!subvalue) {\n    return;\n  }\n\n  index = subvalue.length;\n  length = value.length;\n  queue = '';\n  parenCount = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (whitespace(character) || character === C_LT) {\n      break;\n    }\n\n    if (character === '.' || character === ',' || character === ':' || character === ';' || character === '\"' || character === '\\'' || character === ')' || character === ']') {\n      nextCharacter = value.charAt(index + 1);\n\n      if (!nextCharacter || whitespace(nextCharacter)) {\n        break;\n      }\n    }\n\n    if (character === C_PAREN_OPEN || character === C_BRACKET_OPEN) {\n      parenCount++;\n    }\n\n    if (character === C_PAREN_CLOSE || character === C_BRACKET_CLOSE) {\n      parenCount--;\n\n      if (parenCount < 0) {\n        break;\n      }\n    }\n\n    queue += character;\n    index++;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  subvalue += queue;\n  content = subvalue;\n\n  if (protocol === MAILTO_PROTOCOL) {\n    position = queue.indexOf(C_AT_SIGN);\n\n    if (position === -1 || position === length - 1) {\n      return;\n    }\n\n    content = content.substr(MAILTO_PROTOCOL.length);\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  exit = self.enterLink();\n  content = self.tokenizeInline(content, eat.now());\n  exit();\n  return eat(subvalue)({\n    type: 'link',\n    title: null,\n    url: decode(subvalue, {\n      nonTerminated: false\n    }),\n    children: content\n  });\n}","'use strict';\n\nmodule.exports = locate;\nvar PROTOCOLS = ['https://', 'http://', 'mailto:'];\n\nfunction locate(value, fromIndex) {\n  var length = PROTOCOLS.length;\n  var index = -1;\n  var min = -1;\n  var position;\n\n  if (!this.options.gfm) {\n    return -1;\n  }\n\n  while (++index < length) {\n    position = value.indexOf(PROTOCOLS[index], fromIndex);\n\n    if (position !== -1 && (position < min || min === -1)) {\n      min = position;\n    }\n  }\n\n  return min;\n}","'use strict';\n\nvar alphabetical = require('is-alphabetical');\n\nvar locate = require('../locate/tag');\n\nvar tag = require('../util/html').tag;\n\nmodule.exports = inlineHTML;\ninlineHTML.locator = locate;\nvar EXPRESSION_HTML_LINK_OPEN = /^<a /i;\nvar EXPRESSION_HTML_LINK_CLOSE = /^<\\/a>/i;\n\nfunction inlineHTML(eat, value, silent) {\n  var self = this;\n  var length = value.length;\n  var character;\n  var subvalue;\n\n  if (value.charAt(0) !== '<' || length < 3) {\n    return;\n  }\n\n  character = value.charAt(1);\n\n  if (!alphabetical(character) && character !== '?' && character !== '!' && character !== '/') {\n    return;\n  }\n\n  subvalue = value.match(tag);\n\n  if (!subvalue) {\n    return;\n  }\n  /* istanbul ignore if - not used yet. */\n\n\n  if (silent) {\n    return true;\n  }\n\n  subvalue = subvalue[0];\n\n  if (!self.inLink && EXPRESSION_HTML_LINK_OPEN.test(subvalue)) {\n    self.inLink = true;\n  } else if (self.inLink && EXPRESSION_HTML_LINK_CLOSE.test(subvalue)) {\n    self.inLink = false;\n  }\n\n  return eat(subvalue)({\n    type: 'html',\n    value: subvalue\n  });\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/link');\n\nmodule.exports = link;\nlink.locator = locate;\nvar own = {}.hasOwnProperty;\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_TICK = '`';\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\n/* Map of characters, which can be used to mark link\n * and image titles. */\n\nvar LINK_MARKERS = {};\nLINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nLINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\n/* Map of characters, which can be used to mark link\n * and image titles in commonmark-mode. */\n\nvar COMMONMARK_LINK_MARKERS = {};\nCOMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;\n\nfunction link(eat, value, silent) {\n  var self = this;\n  var subvalue = '';\n  var index = 0;\n  var character = value.charAt(0);\n  var pedantic = self.options.pedantic;\n  var commonmark = self.options.commonmark;\n  var gfm = self.options.gfm;\n  var closed;\n  var count;\n  var opening;\n  var beforeURL;\n  var beforeTitle;\n  var subqueue;\n  var hasMarker;\n  var markers;\n  var isImage;\n  var content;\n  var marker;\n  var length;\n  var title;\n  var depth;\n  var queue;\n  var url;\n  var now;\n  var exit;\n  var node;\n  /* Detect whether this is an image. */\n\n  if (character === '!') {\n    isImage = true;\n    subvalue = character;\n    character = value.charAt(++index);\n  }\n  /* Eat the opening. */\n\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n  /* Exit when this is a link and we’re already inside\n   * a link. */\n\n\n  if (!isImage && self.inLink) {\n    return;\n  }\n\n  subvalue += character;\n  queue = '';\n  index++;\n  /* Eat the content. */\n\n  length = value.length;\n  now = eat.now();\n  depth = 0;\n  now.column += index;\n  now.offset += index;\n\n  while (index < length) {\n    character = value.charAt(index);\n    subqueue = character;\n\n    if (character === C_TICK) {\n      /* Inline-code in link content. */\n      count = 1;\n\n      while (value.charAt(index + 1) === C_TICK) {\n        subqueue += character;\n        index++;\n        count++;\n      }\n\n      if (!opening) {\n        opening = count;\n      } else if (count >= opening) {\n        opening = 0;\n      }\n    } else if (character === C_BACKSLASH) {\n      /* Allow brackets to be escaped. */\n      index++;\n      subqueue += value.charAt(index);\n      /* In GFM mode, brackets in code still count.\n       * In all other modes, they don’t.  This empty\n       * block prevents the next statements are\n       * entered. */\n    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {\n      depth++;\n    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {\n      if (depth) {\n        depth--;\n      } else {\n        /* Allow white-space between content and\n         * url in GFM mode. */\n        if (!pedantic) {\n          while (index < length) {\n            character = value.charAt(index + 1);\n\n            if (!whitespace(character)) {\n              break;\n            }\n\n            subqueue += character;\n            index++;\n          }\n        }\n\n        if (value.charAt(index + 1) !== C_PAREN_OPEN) {\n          return;\n        }\n\n        subqueue += C_PAREN_OPEN;\n        closed = true;\n        index++;\n        break;\n      }\n    }\n\n    queue += subqueue;\n    subqueue = '';\n    index++;\n  }\n  /* Eat the content closing. */\n\n\n  if (!closed) {\n    return;\n  }\n\n  content = queue;\n  subvalue += queue + subqueue;\n  index++;\n  /* Eat white-space. */\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n  /* Eat the URL. */\n\n\n  character = value.charAt(index);\n  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n    beforeURL += C_LT;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_GT) {\n        break;\n      }\n\n      if (commonmark && character === '\\n') {\n        return;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    if (value.charAt(index) !== C_GT) {\n      return;\n    }\n\n    subvalue += C_LT + queue + C_GT;\n    url = queue;\n    index++;\n  } else {\n    character = null;\n    subqueue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (subqueue && own.call(markers, character)) {\n        break;\n      }\n\n      if (whitespace(character)) {\n        if (!pedantic) {\n          break;\n        }\n\n        subqueue += character;\n      } else {\n        if (character === C_PAREN_OPEN) {\n          depth++;\n        } else if (character === C_PAREN_CLOSE) {\n          if (depth === 0) {\n            break;\n          }\n\n          depth--;\n        }\n\n        queue += subqueue;\n        subqueue = '';\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        queue += character;\n      }\n\n      index++;\n    }\n\n    subvalue += queue;\n    url = queue;\n    index = subvalue.length;\n  }\n  /* Eat white-space. */\n\n\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  subvalue += queue;\n  /* Eat the title. */\n\n  if (queue && own.call(markers, character)) {\n    index++;\n    subvalue += character;\n    queue = '';\n    marker = markers[character];\n    beforeTitle = subvalue;\n    /* In commonmark-mode, things are pretty easy: the\n     * marker cannot occur inside the title.\n     *\n     * Non-commonmark does, however, support nested\n     * delimiters. */\n\n    if (commonmark) {\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          break;\n        }\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        index++;\n        queue += character;\n      }\n\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        return;\n      }\n\n      title = queue;\n      subvalue += queue + character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (!whitespace(character)) {\n          break;\n        }\n\n        subvalue += character;\n        index++;\n      }\n    } else {\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          if (hasMarker) {\n            queue += marker + subqueue;\n            subqueue = '';\n          }\n\n          hasMarker = true;\n        } else if (!hasMarker) {\n          queue += character;\n        } else if (character === C_PAREN_CLOSE) {\n          subvalue += queue + marker + subqueue;\n          title = queue;\n          break;\n        } else if (whitespace(character)) {\n          subqueue += character;\n        } else {\n          queue += marker + subqueue + character;\n          subqueue = '';\n          hasMarker = false;\n        }\n\n        index++;\n      }\n    }\n  }\n\n  if (value.charAt(index) !== C_PAREN_CLOSE) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  subvalue += C_PAREN_CLOSE;\n  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {\n    nonTerminated: false\n  });\n\n  if (title) {\n    beforeTitle = eat(beforeTitle).test().end;\n    title = self.decode.raw(self.unescape(title), beforeTitle);\n  }\n\n  node = {\n    type: isImage ? 'image' : 'link',\n    title: title || null,\n    url: url\n  };\n\n  if (isImage) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  } else {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  }\n\n  return eat(subvalue)(node);\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/link');\n\nvar normalize = require('../util/normalize');\n\nmodule.exports = reference;\nreference.locator = locate;\nvar T_LINK = 'link';\nvar T_IMAGE = 'image';\nvar T_FOOTNOTE = 'footnote';\nvar REFERENCE_TYPE_SHORTCUT = 'shortcut';\nvar REFERENCE_TYPE_COLLAPSED = 'collapsed';\nvar REFERENCE_TYPE_FULL = 'full';\nvar C_CARET = '^';\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\n\nfunction reference(eat, value, silent) {\n  var self = this;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = T_LINK;\n  var referenceType = REFERENCE_TYPE_SHORTCUT;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth;\n  /* Check whether we’re eating an image. */\n\n  if (character === '!') {\n    type = T_IMAGE;\n    intro = character;\n    character = value.charAt(++index);\n  }\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  index++;\n  intro += character;\n  queue = '';\n  /* Check whether we’re eating a footnote. */\n\n  if (self.options.footnotes && value.charAt(index) === C_CARET) {\n    /* Exit if `![^` is found, so the `!` will be seen as text after this,\n     * and we’ll enter this function again when `[^` is found. */\n    if (type === T_IMAGE) {\n      return;\n    }\n\n    intro += C_CARET;\n    index++;\n    type = T_FOOTNOTE;\n  }\n  /* Eat the text. */\n\n\n  depth = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_OPEN) {\n      bracketed = true;\n      depth++;\n    } else if (character === C_BRACKET_CLOSE) {\n      if (!depth) {\n        break;\n      }\n\n      depth--;\n    }\n\n    if (character === C_BACKSLASH) {\n      queue += C_BACKSLASH;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n\n  if (character !== C_BRACKET_CLOSE) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  /* Inline footnotes cannot have an identifier. */\n\n  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {\n    identifier = '';\n    queue += character;\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {\n        break;\n      }\n\n      if (character === C_BACKSLASH) {\n        identifier += C_BACKSLASH;\n        character = value.charAt(++index);\n      }\n\n      identifier += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n\n    identifier = content;\n  }\n  /* Brackets cannot be inside the identifier. */\n\n\n  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {\n    return;\n  }\n\n  subvalue = intro + subvalue;\n\n  if (type === T_LINK && self.inLink) {\n    return null;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {\n    return eat(subvalue)({\n      type: 'footnote',\n      children: this.tokenizeInline(content, eat.now())\n    });\n  }\n\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier)\n  };\n\n  if (type === T_LINK || type === T_IMAGE) {\n    node.referenceType = referenceType;\n  }\n\n  if (type === T_LINK) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else if (type === T_IMAGE) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n\n  return eat(subvalue)(node);\n}","'use strict';\n\nvar trim = require('trim');\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/strong');\n\nmodule.exports = strong;\nstrong.locator = locate;\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\n\nfunction strong(eat, value, silent) {\n  var self = this;\n  var index = 0;\n  var character = value.charAt(index);\n  var now;\n  var pedantic;\n  var marker;\n  var queue;\n  var subvalue;\n  var length;\n  var prev;\n\n  if (character !== C_ASTERISK && character !== C_UNDERSCORE || value.charAt(++index) !== character) {\n    return;\n  }\n\n  pedantic = self.options.pedantic;\n  marker = character;\n  subvalue = marker + marker;\n  length = value.length;\n  index++;\n  queue = '';\n  character = '';\n\n  if (pedantic && whitespace(value.charAt(index))) {\n    return;\n  }\n\n  while (index < length) {\n    prev = character;\n    character = value.charAt(index);\n\n    if (character === marker && value.charAt(index + 1) === marker && (!pedantic || !whitespace(prev))) {\n      character = value.charAt(index + 2);\n\n      if (character !== marker) {\n        if (!trim(queue)) {\n          return;\n        }\n        /* istanbul ignore if - never used (yet) */\n\n\n        if (silent) {\n          return true;\n        }\n\n        now = eat.now();\n        now.column += 2;\n        now.offset += 2;\n        return eat(subvalue + queue + subvalue)({\n          type: 'strong',\n          children: self.tokenizeInline(queue, now)\n        });\n      }\n    }\n\n    if (!pedantic && character === '\\\\') {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n}","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var asterisk = value.indexOf('**', fromIndex);\n  var underscore = value.indexOf('__', fromIndex);\n\n  if (underscore === -1) {\n    return asterisk;\n  }\n\n  if (asterisk === -1) {\n    return underscore;\n  }\n\n  return underscore < asterisk ? underscore : asterisk;\n}","'use strict';\n\nvar trim = require('trim');\n\nvar word = require('is-word-character');\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/emphasis');\n\nmodule.exports = emphasis;\nemphasis.locator = locate;\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\n\nfunction emphasis(eat, value, silent) {\n  var self = this;\n  var index = 0;\n  var character = value.charAt(index);\n  var now;\n  var pedantic;\n  var marker;\n  var queue;\n  var subvalue;\n  var length;\n  var prev;\n\n  if (character !== C_ASTERISK && character !== C_UNDERSCORE) {\n    return;\n  }\n\n  pedantic = self.options.pedantic;\n  subvalue = character;\n  marker = character;\n  length = value.length;\n  index++;\n  queue = '';\n  character = '';\n\n  if (pedantic && whitespace(value.charAt(index))) {\n    return;\n  }\n\n  while (index < length) {\n    prev = character;\n    character = value.charAt(index);\n\n    if (character === marker && (!pedantic || !whitespace(prev))) {\n      character = value.charAt(++index);\n\n      if (character !== marker) {\n        if (!trim(queue) || prev === marker) {\n          return;\n        }\n\n        if (!pedantic && marker === C_UNDERSCORE && word(character)) {\n          queue += marker;\n          continue;\n        }\n        /* istanbul ignore if - never used (yet) */\n\n\n        if (silent) {\n          return true;\n        }\n\n        now = eat.now();\n        now.column++;\n        now.offset++;\n        return eat(subvalue + queue + marker)({\n          type: 'emphasis',\n          children: self.tokenizeInline(queue, now)\n        });\n      }\n\n      queue += marker;\n    }\n\n    if (!pedantic && character === '\\\\') {\n      queue += character;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n}","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var asterisk = value.indexOf('*', fromIndex);\n  var underscore = value.indexOf('_', fromIndex);\n\n  if (underscore === -1) {\n    return asterisk;\n  }\n\n  if (asterisk === -1) {\n    return underscore;\n  }\n\n  return underscore < asterisk ? underscore : asterisk;\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/delete');\n\nmodule.exports = strikethrough;\nstrikethrough.locator = locate;\nvar C_TILDE = '~';\nvar DOUBLE = '~~';\n\nfunction strikethrough(eat, value, silent) {\n  var self = this;\n  var character = '';\n  var previous = '';\n  var preceding = '';\n  var subvalue = '';\n  var index;\n  var length;\n  var now;\n\n  if (!self.options.gfm || value.charAt(0) !== C_TILDE || value.charAt(1) !== C_TILDE || whitespace(value.charAt(2))) {\n    return;\n  }\n\n  index = 1;\n  length = value.length;\n  now = eat.now();\n  now.column += 2;\n  now.offset += 2;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TILDE && previous === C_TILDE && (!preceding || !whitespace(preceding))) {\n      /* istanbul ignore if - never used (yet) */\n      if (silent) {\n        return true;\n      }\n\n      return eat(DOUBLE + subvalue + DOUBLE)({\n        type: 'delete',\n        children: self.tokenizeInline(subvalue, now)\n      });\n    }\n\n    subvalue += previous;\n    preceding = previous;\n    previous = character;\n  }\n}","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('~~', fromIndex);\n}","'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/code-inline');\n\nmodule.exports = inlineCode;\ninlineCode.locator = locate;\nvar C_TICK = '`';\n/* Tokenise inline code. */\n\nfunction inlineCode(eat, value, silent) {\n  var length = value.length;\n  var index = 0;\n  var queue = '';\n  var tickQueue = '';\n  var contentQueue;\n  var subqueue;\n  var count;\n  var openingCount;\n  var subvalue;\n  var character;\n  var found;\n  var next;\n\n  while (index < length) {\n    if (value.charAt(index) !== C_TICK) {\n      break;\n    }\n\n    queue += C_TICK;\n    index++;\n  }\n\n  if (!queue) {\n    return;\n  }\n\n  subvalue = queue;\n  openingCount = index;\n  queue = '';\n  next = value.charAt(index);\n  count = 0;\n\n  while (index < length) {\n    character = next;\n    next = value.charAt(index + 1);\n\n    if (character === C_TICK) {\n      count++;\n      tickQueue += character;\n    } else {\n      count = 0;\n      queue += character;\n    }\n\n    if (count && next !== C_TICK) {\n      if (count === openingCount) {\n        subvalue += queue + tickQueue;\n        found = true;\n        break;\n      }\n\n      queue += tickQueue;\n      tickQueue = '';\n    }\n\n    index++;\n  }\n\n  if (!found) {\n    if (openingCount % 2 !== 0) {\n      return;\n    }\n\n    queue = '';\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  contentQueue = '';\n  subqueue = '';\n  length = queue.length;\n  index = -1;\n\n  while (++index < length) {\n    character = queue.charAt(index);\n\n    if (whitespace(character)) {\n      subqueue += character;\n      continue;\n    }\n\n    if (subqueue) {\n      if (contentQueue) {\n        contentQueue += subqueue;\n      }\n\n      subqueue = '';\n    }\n\n    contentQueue += character;\n  }\n\n  return eat(subvalue)({\n    type: 'inlineCode',\n    value: contentQueue\n  });\n}","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  return value.indexOf('`', fromIndex);\n}","'use strict';\n\nvar locate = require('../locate/break');\n\nmodule.exports = hardBreak;\nhardBreak.locator = locate;\nvar MIN_BREAK_LENGTH = 2;\n\nfunction hardBreak(eat, value, silent) {\n  var length = value.length;\n  var index = -1;\n  var queue = '';\n  var character;\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === '\\n') {\n      if (index < MIN_BREAK_LENGTH) {\n        return;\n      }\n      /* istanbul ignore if - never used (yet) */\n\n\n      if (silent) {\n        return true;\n      }\n\n      queue += character;\n      return eat(queue)({\n        type: 'break'\n      });\n    }\n\n    if (character !== ' ') {\n      return;\n    }\n\n    queue += character;\n  }\n}","'use strict';\n\nmodule.exports = locate;\n\nfunction locate(value, fromIndex) {\n  var index = value.indexOf('\\n', fromIndex);\n\n  while (index > fromIndex) {\n    if (value.charAt(index - 1) !== ' ') {\n      break;\n    }\n\n    index--;\n  }\n\n  return index;\n}","'use strict';\n\nmodule.exports = text;\n\nfunction text(eat, value, silent) {\n  var self = this;\n  var methods;\n  var tokenizers;\n  var index;\n  var length;\n  var subvalue;\n  var position;\n  var tokenizer;\n  var name;\n  var min;\n  var now;\n  /* istanbul ignore if - never used (yet) */\n\n  if (silent) {\n    return true;\n  }\n\n  methods = self.inlineMethods;\n  length = methods.length;\n  tokenizers = self.inlineTokenizers;\n  index = -1;\n  min = value.length;\n\n  while (++index < length) {\n    name = methods[index];\n\n    if (name === 'text' || !tokenizers[name]) {\n      continue;\n    }\n\n    tokenizer = tokenizers[name].locator;\n\n    if (!tokenizer) {\n      eat.file.fail('Missing locator: `' + name + '`');\n    }\n\n    position = tokenizer.call(self, value, 1);\n\n    if (position !== -1 && position < min) {\n      min = position;\n    }\n  }\n\n  subvalue = value.slice(0, min);\n  now = eat.now();\n  self.decode(subvalue, now, function (content, position, source) {\n    eat(source || content)({\n      type: 'text',\n      value: content\n    });\n  });\n}"],"sourceRoot":""}