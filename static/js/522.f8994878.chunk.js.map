{"version":3,"sources":["../node_modules/codemirror/mode/swift/swift.js"],"names":["CodeMirror","wordSet","words","set","i","length","keywords","definingKeywords","atoms","types","binary","octal","hexadecimal","decimal","identifier","property","instruction","attribute","tokenBase","stream","state","prev","sol","indented","indentation","eatSpace","stringMatch","ch","peek","match","skipToEnd","tokenize","push","tokenComment","indexOf","next","tokenString","bind","ident","current","hasOwnProperty","tokenUntilClosingParen","depth","inner","backUp","pop","openQuote","singleLine","escaped","eat","Context","align","this","pushContext","column","context","popContext","defineMode","config","startState","token","style","bracket","exec","indent","textAfter","cx","closing","test","indentUnit","electricInput","lineComment","blockCommentStart","blockCommentEnd","fold","closeBrackets","defineMIME","mod"],"mappings":"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","file":"static/js/522.f8994878.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Swift mode created by Michael Kaminsky https://github.com/mkaminsky11\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) define([\"../../lib/codemirror\"], mod);else mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function wordSet(words) {\n    var set = {};\n\n    for (var i = 0; i < words.length; i++) {\n      set[words[i]] = true;\n    }\n\n    return set;\n  }\n\n  var keywords = wordSet([\"_\", \"var\", \"let\", \"class\", \"enum\", \"extension\", \"import\", \"protocol\", \"struct\", \"func\", \"typealias\", \"associatedtype\", \"open\", \"public\", \"internal\", \"fileprivate\", \"private\", \"deinit\", \"init\", \"new\", \"override\", \"self\", \"subscript\", \"super\", \"convenience\", \"dynamic\", \"final\", \"indirect\", \"lazy\", \"required\", \"static\", \"unowned\", \"unowned(safe)\", \"unowned(unsafe)\", \"weak\", \"as\", \"is\", \"break\", \"case\", \"continue\", \"default\", \"else\", \"fallthrough\", \"for\", \"guard\", \"if\", \"in\", \"repeat\", \"switch\", \"where\", \"while\", \"defer\", \"return\", \"inout\", \"mutating\", \"nonmutating\", \"catch\", \"do\", \"rethrows\", \"throw\", \"throws\", \"try\", \"didSet\", \"get\", \"set\", \"willSet\", \"assignment\", \"associativity\", \"infix\", \"left\", \"none\", \"operator\", \"postfix\", \"precedence\", \"precedencegroup\", \"prefix\", \"right\", \"Any\", \"AnyObject\", \"Type\", \"dynamicType\", \"Self\", \"Protocol\", \"__COLUMN__\", \"__FILE__\", \"__FUNCTION__\", \"__LINE__\"]);\n  var definingKeywords = wordSet([\"var\", \"let\", \"class\", \"enum\", \"extension\", \"import\", \"protocol\", \"struct\", \"func\", \"typealias\", \"associatedtype\", \"for\"]);\n  var atoms = wordSet([\"true\", \"false\", \"nil\", \"self\", \"super\", \"_\"]);\n  var types = wordSet([\"Array\", \"Bool\", \"Character\", \"Dictionary\", \"Double\", \"Float\", \"Int\", \"Int8\", \"Int16\", \"Int32\", \"Int64\", \"Never\", \"Optional\", \"Set\", \"String\", \"UInt8\", \"UInt16\", \"UInt32\", \"UInt64\", \"Void\"]);\n  var operators = \"+-/*%=|&<>~^?!\";\n  var punc = \":;,.(){}[]\";\n  var binary = /^\\-?0b[01][01_]*/;\n  var octal = /^\\-?0o[0-7][0-7_]*/;\n  var hexadecimal = /^\\-?0x[\\dA-Fa-f][\\dA-Fa-f_]*(?:(?:\\.[\\dA-Fa-f][\\dA-Fa-f_]*)?[Pp]\\-?\\d[\\d_]*)?/;\n  var decimal = /^\\-?\\d[\\d_]*(?:\\.\\d[\\d_]*)?(?:[Ee]\\-?\\d[\\d_]*)?/;\n  var identifier = /^\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1/;\n  var property = /^\\.(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/;\n  var instruction = /^\\#[A-Za-z]+/;\n  var attribute = /^@(?:\\$\\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\\1)/; //var regexp = /^\\/(?!\\s)(?:\\/\\/)?(?:\\\\.|[^\\/])+\\//\n\n  function tokenBase(stream, state, prev) {\n    if (stream.sol()) state.indented = stream.indentation();\n    if (stream.eatSpace()) return null;\n    var ch = stream.peek();\n\n    if (ch == \"/\") {\n      if (stream.match(\"//\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(\"/*\")) {\n        state.tokenize.push(tokenComment);\n        return tokenComment(stream, state);\n      }\n    }\n\n    if (stream.match(instruction)) return \"builtin\";\n    if (stream.match(attribute)) return \"attribute\";\n    if (stream.match(binary)) return \"number\";\n    if (stream.match(octal)) return \"number\";\n    if (stream.match(hexadecimal)) return \"number\";\n    if (stream.match(decimal)) return \"number\";\n    if (stream.match(property)) return \"property\";\n\n    if (operators.indexOf(ch) > -1) {\n      stream.next();\n      return \"operator\";\n    }\n\n    if (punc.indexOf(ch) > -1) {\n      stream.next();\n      stream.match(\"..\");\n      return \"punctuation\";\n    }\n\n    var stringMatch;\n\n    if (stringMatch = stream.match(/(\"\"\"|\"|')/)) {\n      var tokenize = tokenString.bind(null, stringMatch[0]);\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n\n    if (stream.match(identifier)) {\n      var ident = stream.current();\n      if (types.hasOwnProperty(ident)) return \"variable-2\";\n      if (atoms.hasOwnProperty(ident)) return \"atom\";\n\n      if (keywords.hasOwnProperty(ident)) {\n        if (definingKeywords.hasOwnProperty(ident)) state.prev = \"define\";\n        return \"keyword\";\n      }\n\n      if (prev == \"define\") return \"def\";\n      return \"variable\";\n    }\n\n    stream.next();\n    return null;\n  }\n\n  function tokenUntilClosingParen() {\n    var depth = 0;\n    return function (stream, state, prev) {\n      var inner = tokenBase(stream, state, prev);\n\n      if (inner == \"punctuation\") {\n        if (stream.current() == \"(\") ++depth;else if (stream.current() == \")\") {\n          if (depth == 0) {\n            stream.backUp(1);\n            state.tokenize.pop();\n            return state.tokenize[state.tokenize.length - 1](stream, state);\n          } else --depth;\n        }\n      }\n\n      return inner;\n    };\n  }\n\n  function tokenString(openQuote, stream, state) {\n    var singleLine = openQuote.length == 1;\n    var ch,\n        escaped = false;\n\n    while (ch = stream.peek()) {\n      if (escaped) {\n        stream.next();\n\n        if (ch == \"(\") {\n          state.tokenize.push(tokenUntilClosingParen());\n          return \"string\";\n        }\n\n        escaped = false;\n      } else if (stream.match(openQuote)) {\n        state.tokenize.pop();\n        return \"string\";\n      } else {\n        stream.next();\n        escaped = ch == \"\\\\\";\n      }\n    }\n\n    if (singleLine) {\n      state.tokenize.pop();\n    }\n\n    return \"string\";\n  }\n\n  function tokenComment(stream, state) {\n    var ch;\n\n    while (true) {\n      stream.match(/^[^/*]+/, true);\n      ch = stream.next();\n      if (!ch) break;\n\n      if (ch === \"/\" && stream.eat(\"*\")) {\n        state.tokenize.push(tokenComment);\n      } else if (ch === \"*\" && stream.eat(\"/\")) {\n        state.tokenize.pop();\n      }\n    }\n\n    return \"comment\";\n  }\n\n  function Context(prev, align, indented) {\n    this.prev = prev;\n    this.align = align;\n    this.indented = indented;\n  }\n\n  function pushContext(state, stream) {\n    var align = stream.match(/^\\s*($|\\/[\\/\\*])/, false) ? null : stream.column() + 1;\n    state.context = new Context(state.context, align, state.indented);\n  }\n\n  function popContext(state) {\n    if (state.context) {\n      state.indented = state.context.indented;\n      state.context = state.context.prev;\n    }\n  }\n\n  CodeMirror.defineMode(\"swift\", function (config) {\n    return {\n      startState: function startState() {\n        return {\n          prev: null,\n          context: null,\n          indented: 0,\n          tokenize: []\n        };\n      },\n      token: function token(stream, state) {\n        var prev = state.prev;\n        state.prev = null;\n        var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase;\n        var style = tokenize(stream, state, prev);\n        if (!style || style == \"comment\") state.prev = prev;else if (!state.prev) state.prev = style;\n\n        if (style == \"punctuation\") {\n          var bracket = /[\\(\\[\\{]|([\\]\\)\\}])/.exec(stream.current());\n          if (bracket) (bracket[1] ? popContext : pushContext)(state, stream);\n        }\n\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        var cx = state.context;\n        if (!cx) return 0;\n        var closing = /^[\\]\\}\\)]/.test(textAfter);\n        if (cx.align != null) return cx.align - (closing ? 1 : 0);\n        return cx.indented + (closing ? 0 : config.indentUnit);\n      },\n      electricInput: /^\\s*[\\)\\}\\]]$/,\n      lineComment: \"//\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      fold: \"brace\",\n      closeBrackets: \"()[]{}''\\\"\\\"``\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-swift\", \"swift\");\n});"],"sourceRoot":""}