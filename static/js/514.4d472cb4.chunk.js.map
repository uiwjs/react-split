{"version":3,"sources":["../node_modules/codemirror/mode/sieve/sieve.js"],"names":["CodeMirror","defineMode","config","words","str","obj","split","i","length","keywords","atoms","indentUnit","tokenBase","stream","state","quote","ch","next","eat","tokenize","tokenCComment","skipToEnd","escaped","_indent","push","pop","test","eatWhile","cur","current","tokenMultiLineString","propertyIsEnumerable","_multiLineString","sol","eol","eatSpace","peek","maybeEnd","startState","base","baseIndent","token","indent","_textAfter","electricChars","defineMIME","mod"],"mappings":"mHAOG,SAAUA,GACX,aAEAA,EAAWC,WAAW,SAAS,SAAUC,GACvC,SAASC,EAAMC,GAIb,IAHA,IAAIC,EAAM,GACNF,EAAQC,EAAIE,MAAM,KAEbC,EAAI,EAAGA,EAAIJ,EAAMK,SAAUD,EAClCF,EAAIF,EAAMI,KAAM,EAGlB,OAAOF,EAGT,IAAII,EAAWN,EAAM,8BACjBO,EAAQP,EAAM,kBACdQ,EAAaT,EAAOS,WAExB,SAASC,EAAUC,EAAQC,GACzB,IAoHmBC,EApHfC,EAAKH,EAAOI,OAEhB,GAAU,KAAND,GAAaH,EAAOK,IAAI,KAE1B,OADAJ,EAAMK,SAAWC,EACVA,EAAcP,EAAQC,GAG/B,GAAW,MAAPE,EAEF,OADAH,EAAOQ,YACA,UAGT,GAAU,KAANL,EAEF,OADAF,EAAMK,UAuGWJ,EAvGYC,EAwGxB,SAAUH,EAAQC,GAIvB,IAHA,IACIE,EADAM,GAAU,EAGiB,OAAvBN,EAAKH,EAAOI,UACdD,GAAMD,GAAUO,IACpBA,GAAWA,GAAiB,MAANN,EAIxB,OADKM,IAASR,EAAMK,SAAWP,GACxB,WAjHAE,EAAMK,SAASN,EAAQC,GAGhC,GAAU,KAANE,EAOF,OANAF,EAAMS,QAAQC,KAAK,KAInBV,EAAMS,QAAQC,KAAK,KAEZ,KAGT,GAAW,MAAPR,EAGF,OAFAF,EAAMS,QAAQC,KAAK,KAEZ,KAST,GANU,KAANR,IACFF,EAAMS,QAAQE,MAEdX,EAAMS,QAAQE,OAGL,MAAPT,EAGF,OAFAF,EAAMS,QAAQE,MAEP,KAGT,GAAU,KAANT,EAAW,OAAO,KACtB,GAAU,KAANA,EAAW,OAAO,KACtB,GAAI,aAAaU,KAAKV,GAAK,OAAO,KAElC,GAAI,KAAKU,KAAKV,GAGZ,OAFAH,EAAOc,SAAS,QAChBd,EAAOK,IAAI,YACJ,SAIT,GAAU,KAANF,EAGF,OAFAH,EAAOc,SAAS,aAChBd,EAAOc,SAAS,gBACT,WAGTd,EAAOc,SAAS,MAChB,IAAIC,EAAMf,EAAOgB,UAIjB,MAAW,QAAPD,GAAiBf,EAAOK,IAAI,MAC9BJ,EAAMK,SAAWW,EACV,UAGLrB,EAASsB,qBAAqBH,GAAa,UAC3ClB,EAAMqB,qBAAqBH,GAAa,OACrC,KAGT,SAASE,EAAqBjB,EAAQC,GAGpC,OAFAA,EAAMkB,kBAAmB,EAEpBnB,EAAOoB,OAYS,KAAjBpB,EAAOI,QAAiBJ,EAAOqB,QACjCpB,EAAMkB,kBAAmB,EACzBlB,EAAMK,SAAWP,GAGZ,WAhBLC,EAAOsB,WAEc,KAAjBtB,EAAOuB,QACTvB,EAAOQ,YACA,YAGTR,EAAOQ,YACA,WAWX,SAASD,EAAcP,EAAQC,GAI7B,IAHA,IACIE,EADAqB,GAAW,EAGgB,OAAvBrB,EAAKH,EAAOI,SAAiB,CACnC,GAAIoB,GAAkB,KAANrB,EAAW,CACzBF,EAAMK,SAAWP,EACjB,MAGFyB,EAAiB,KAANrB,EAGb,MAAO,UAkBT,MAAO,CACLsB,WAAY,SAAoBC,GAC9B,MAAO,CACLpB,SAAUP,EACV4B,WAAYD,GAAQ,EACpBhB,QAAS,KAGbkB,MAAO,SAAe5B,EAAQC,GAC5B,OAAID,EAAOsB,WAAmB,MACtBrB,EAAMK,UAAYP,GAAWC,EAAQC,IAE/C4B,OAAQ,SAAgB5B,EAAO6B,GAC7B,IAAInC,EAASM,EAAMS,QAAQf,OAG3B,OAFImC,GAA+B,KAAjBA,EAAW,IAAWnC,IACpCA,EAAS,IAAGA,EAAS,GAClBA,EAASG,GAElBiC,cAAe,QAGnB5C,EAAW6C,WAAW,oBAAqB,SA/KzCC,CAAI,EAAQ","file":"static/js/514.4d472cb4.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"sieve\", function (config) {\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) {\n        obj[words[i]] = true;\n      }\n\n      return obj;\n    }\n\n    var keywords = words(\"if elsif else stop require\");\n    var atoms = words(\"true false not\");\n    var indentUnit = config.indentUnit;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == \"/\" && stream.eat(\"*\")) {\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n\n      if (ch === '#') {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (ch == \"\\\"\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      }\n\n      if (ch == \"(\") {\n        state._indent.push(\"(\"); // add virtual angel wings so that editor behaves...\n        // ...more sane incase of broken brackets\n\n\n        state._indent.push(\"{\");\n\n        return null;\n      }\n\n      if (ch === \"{\") {\n        state._indent.push(\"{\");\n\n        return null;\n      }\n\n      if (ch == \")\") {\n        state._indent.pop();\n\n        state._indent.pop();\n      }\n\n      if (ch === \"}\") {\n        state._indent.pop();\n\n        return null;\n      }\n\n      if (ch == \",\") return null;\n      if (ch == \";\") return null;\n      if (/[{}\\(\\),;]/.test(ch)) return null; // 1*DIGIT \"K\" / \"M\" / \"G\"\n\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\d]/);\n        stream.eat(/[KkMmGg]/);\n        return \"number\";\n      } // \":\" (ALPHA / \"_\") *(ALPHA / DIGIT / \"_\")\n\n\n      if (ch == \":\") {\n        stream.eatWhile(/[a-zA-Z_]/);\n        stream.eatWhile(/[a-zA-Z0-9_]/);\n        return \"operator\";\n      }\n\n      stream.eatWhile(/\\w/);\n      var cur = stream.current(); // \"text:\" *(SP / HTAB) (hash-comment / CRLF)\n      // *(multiline-literal / multiline-dotstart)\n      // \".\" CRLF\n\n      if (cur == \"text\" && stream.eat(\":\")) {\n        state.tokenize = tokenMultiLineString;\n        return \"string\";\n      }\n\n      if (keywords.propertyIsEnumerable(cur)) return \"keyword\";\n      if (atoms.propertyIsEnumerable(cur)) return \"atom\";\n      return null;\n    }\n\n    function tokenMultiLineString(stream, state) {\n      state._multiLineString = true; // the first line is special it may contain a comment\n\n      if (!stream.sol()) {\n        stream.eatSpace();\n\n        if (stream.peek() == \"#\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        stream.skipToEnd();\n        return \"string\";\n      }\n\n      if (stream.next() == \".\" && stream.eol()) {\n        state._multiLineString = false;\n        state.tokenize = tokenBase;\n      }\n\n      return \"string\";\n    }\n\n    function tokenCComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while ((ch = stream.next()) != null) {\n        if (maybeEnd && ch == \"/\") {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            ch;\n\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && !escaped) break;\n          escaped = !escaped && ch == \"\\\\\";\n        }\n\n        if (!escaped) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    return {\n      startState: function startState(base) {\n        return {\n          tokenize: tokenBase,\n          baseIndent: base || 0,\n          _indent: []\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.eatSpace()) return null;\n        return (state.tokenize || tokenBase)(stream, state);\n      },\n      indent: function indent(state, _textAfter) {\n        var length = state._indent.length;\n        if (_textAfter && _textAfter[0] == \"}\") length--;\n        if (length < 0) length = 0;\n        return length * indentUnit;\n      },\n      electricChars: \"}\"\n    };\n  });\n  CodeMirror.defineMIME(\"application/sieve\", \"sieve\");\n});"],"sourceRoot":""}