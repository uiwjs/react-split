{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/node_modules/debug/src/browser.js","../node_modules/@babel/traverse/node_modules/debug/src/common.js","../node_modules/@babel/traverse/node_modules/ms/index.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js"],"names":["Object","defineProperty","exports","value","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","t","require","types","checkPath","path","opts","node","parent","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","parentPath","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isScope","isBlockScoped","isVar","loc","isUser","scope","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await","default","_renamer","_index","_binding","_globals","_cache","gatherNodeParts","parts","type","isModuleDeclaration","isExportAllDeclaration","isExportNamedDeclaration","source","specifiers","length","isExportDefaultDeclaration","declaration","isModuleSpecifier","local","isLiteral","push","object","property","callee","properties","argument","key","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","For","FOR_INIT_KEYS","declar","get","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","ImportDeclaration","getBlockParent","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","declarations","decl","keys","getBindingIdentifiers","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","isFunctionExpression","has","NOT_LOCAL_BINDING","params","param","ClassExpression","uid","this","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","isKey","isMethod","hub","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","join","slice","generateUidBasedOnNode","isThisExpression","isSuper","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","buildError","TypeError","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","unshift","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","unaryExpression","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elements","elem","prop","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","isPureish","val","crawl","create","programParent","_exploded","enter","visit","typeVisitors","traverse","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","variableDeclaration","unshiftContainer","setData","declarator","variableDeclarator","pop","Error","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","indexOf","enumerable","_path","_scope","_hub","visitors","_context","cache","noScope","VISITOR_KEYS","explode","_default","hasDenylistedType","stop","verify","cheap","traverseFast","skipKeys","context","clearNode","removeProperties","delete","tree","hasType","denylistTypes","denylist","SHOULD_SKIP","SHOULD_STOP","REMOVED","virtualTypes","_debug","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","debug","NodePath","contexts","_traverseFlags","container","listKey","def","undefined","msg","SyntaxError","visitor","validate","inList","message","enabled","getPathLocation","code","v","targetNode","paths","setup","assign","prototype","TYPES","typeKey","fn","virtualType","clear","clearPath","clearScope","WeakMap","TraversalContext","queue","priorityQueue","obj","notPriority","shouldVisit","visitQueue","visited","WeakSet","resync","pushContext","add","popContext","nodes","Array","isArray","visitMultiple","visitSingle","formatArgs","useColors","module","humanize","diff","c","color","splice","index","lastC","match","save","namespaces","storage","setItem","removeItem","error","load","r","getItem","process","DEBUG","window","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","localStorage","localstorage","destroy","warned","warn","colors","formatters","j","JSON","stringify","env","createDebug","prevTime","namespacesCache","enabledCache","enableOverride","self","curr","Number","Date","ms","prev","coerce","format","formatter","call","logFn","apply","selectColor","extend","configurable","delimiter","newDebug","toNamespace","regexp","toString","substring","stack","disable","names","skips","enable","split","len","substr","test","forEach","hash","charCodeAt","Math","abs","s","m","h","d","w","y","plural","msAbs","n","isPlural","round","options","str","String","exec","parseFloat","parse","isFinite","long","fmtLong","fmtShort","_helperSplitExportDeclaration","renameVisitor","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","findParent","callback","p","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isStringTypeAnnotation","isNumberTypeAnnotation","isBooleanTypeAnnotation","isMixedTypeAnnotation","isEmptyTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","concat","violation","getTypeAnnotationBindingConstantViolations","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","BOOLEAN_NUMBER_BINARY_OPERATORS","typeValue","createTypeAnnotationBasedOnTypeof","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","err","_codeFrame","codeFrameColumns","start","line","column","replaceWith","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","toSequenceExpression","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","_helperHoistVariables","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","assignmentExpression","arrowFunctionToExpression","newCallee","needToAwaitFunction","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_containerInsertAfter","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","isSequenceExpression","exprs","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","pow","func","global","_evaluate","raw","cooked","expr","toComputedKey","stringLiteral","bodyNode","statements","stringPath","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","conditionalExpression","binaryExpression","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","metaProperty","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","jsxIdentifier","assignmentPath","op","tmp","isUpdateExpression","updateExpr","computedKey","sequenceExpression","isClassMethod","supers","argsBinding","restElement","super","spreadElement","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","fns","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","updateSiblingKeys","isWhile","isSwitchCase","insertBefore","nodes_","isJSXElement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","assertExpression","temp","fromIndex","incrementBy","verifiedNodes","hoist","hoister","_hoister","run","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","jsxExpressionContainer","getOpposite","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","_getKey","_getPattern","_","part","duplicates","getBindingIdentifierPaths","outerOnly","search","shift","_ids","getOuterBindingIdentifierPaths","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","pathCompletions","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","trailing","trailingComments","leading","leadingComments","next","hasPrev","Boolean","hasNext","addComments","addComment","content","comments","merge","states","wrapper","rootVisitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","nodeType","shouldIgnoreKey","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","trace","alias","_verified","validateVisitorMethods","visitorKey","oldVisitor","newVisitor","newFn","arguments","dest","src","Hub"],"mappings":"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","file":"static/js/vendors-runtime-traverse.2515d327.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = require(\"./context\");\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!t.VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return t.traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  t.removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  t.traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    t.validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"./path\");\n\nvar t = require(\"@babel/types\");\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = t.VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar t = require(\"@babel/types\");\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar t = require(\"@babel/types\");\n\nvar _index = require(\"./index\");\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = t.VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar t = require(\"@babel/types\");\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return t.isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation(left) && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return t.stringTypeAnnotation();\n    }\n\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (t.isTSTypeAnnotation(argumentTypes[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(argumentTypes);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(argumentTypes);\n  }\n\n  return t.createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return t.stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return t.numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return t.booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return t.nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nconst isArrayFrom = t.buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = t.buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = t.buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = t.buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return t.arrayTypeAnnotation(t.stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return t.arrayTypeAnnotation(t.anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return t.arrayTypeAnnotation(t.tupleTypeAnnotation([t.stringTypeAnnotation(), t.anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = require(\"@babel/types\");\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = t.expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    t.inheritsComments(replacement, oldNode);\n    t.removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    t.validate(this.parent, this.key, [node]);\n  } else {\n    t.validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = t.arrowFunctionExpression([], t.blockStatement(nodes));\n  this.replaceWith(t.callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", t.returnStatement(t.cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = t.identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", t.cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(t.returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", t.FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", t.FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(t.awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(t.yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar t = require(\"@babel/types\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (t.isIdentifier(key)) key = t.stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(t.returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(t.expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = t.blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: t.objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(this.hub.addHelper(\"newArrowCheck\"), [t.thisExpression(), checkBinding ? t.identifier(checkBinding.name) : t.identifier(thisBinding)])));\n    this.replaceWith(t.callExpression(t.memberExpression((0, _helperFunctionName.default)(this, true) || this.node, t.identifier(\"bind\")), [checkBinding ? t.identifier(checkBinding.name) : t.thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = t.identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => t.identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return t.conditionalExpression(t.binaryExpression(\"===\", t.unaryExpression(\"typeof\", args()), t.stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = t.identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => t.metaProperty(t.identifier(\"new\"), t.identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = t.identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = t.callExpression(t.identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", t.thisExpression());\n        superProp.replaceWith(t.memberExpression(call, t.identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? t.jsxIdentifier(thisBinding) : t.identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, t.assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(t.memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(t.binaryExpression(op, t.memberExpression(superProp.node.object, t.identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [t.assignmentExpression(\"=\", tmp, t.memberExpression(superProp.node.object, computedKey ? t.assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), t.assignmentExpression(\"=\", t.memberExpression(superProp.node.object, computedKey ? t.identifier(computedKey.name) : superProp.node.property, superProp.node.computed), t.binaryExpression(\"+\", t.identifier(tmp.name), t.numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(t.identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(t.sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return t.thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, t.assignmentExpression(\"=\", t.identifier(thisBinding), t.identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return t.arrowFunctionExpression([t.restElement(argsBinding)], t.callExpression(t.super(), [t.spreadElement(t.identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = t.memberExpression(t.super(), t.identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = t.memberExpression(t.super(), t.identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = t.assignmentExpression(\"=\", fnBody, t.identifier(valueIdent.name));\n    }\n\n    return t.arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      let curr = child.scope;\n\n      do {\n        if (curr.hasOwnBinding(\"arguments\")) {\n          curr.rename(\"arguments\");\n          return;\n        }\n\n        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (curr = curr.parent);\n\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar t = require(\"@babel/types\");\n\nfunction matchesPattern(pattern, allowPartial) {\n  return t.matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return t.STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? t.isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && t.isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = t.VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!t.isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) return records.concat(_getCompletionRecords(path, context));\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records = records.concat(breakCompletions);\n  }\n\n  records = records.concat(lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(t.unaryExpression(\"void\", t.numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  let completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n          newContext.shouldPopulateBreak = true;\n        } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions = completions.concat(lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions = completions.concat(statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions = completions.concat(statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions = completions.concat(statementCompletions);\n      } else {\n        completions = completions.concat(statementCompletions.filter(c => c.type === BREAK_COMPLETION));\n        lastNormalCompletions = statementCompletions.filter(c => c.type === NORMAL_COMPLETION);\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions = completions.concat(pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    records = records.concat(getStatementListCompletion(path.get(\"body\"), context));\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    records = addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    records = completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    records = records.concat(getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    }));\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return t.getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  let search = [].concat(path);\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = t.getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (declaration.isDeclaration()) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child) || child.node) {\n          search = search.concat(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar t = require(\"@babel/types\");\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  t.addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  t.addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar t = require(\"@babel/types\");\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;"],"sourceRoot":""}