{"version":3,"sources":["../node_modules/@babel/traverse/lib/path/lib/virtual-types.js","../node_modules/@babel/traverse/lib/scope/index.js","../node_modules/@babel/traverse/lib/scope/binding.js","../node_modules/@babel/traverse/lib/index.js","../node_modules/@babel/traverse/lib/path/index.js","../node_modules/@babel/traverse/lib/cache.js","../node_modules/@babel/traverse/lib/context.js","../node_modules/@babel/traverse/node_modules/debug/src/browser.js","../node_modules/@babel/traverse/node_modules/debug/src/common.js","../node_modules/@babel/traverse/node_modules/ms/index.js","../node_modules/@babel/traverse/lib/scope/lib/renamer.js","../node_modules/@babel/traverse/lib/path/ancestry.js","../node_modules/@babel/traverse/lib/path/inference/index.js","../node_modules/@babel/traverse/lib/path/inference/inferers.js","../node_modules/@babel/traverse/lib/path/inference/inferer-reference.js","../node_modules/@babel/traverse/lib/path/replacement.js","../node_modules/@babel/traverse/lib/path/evaluation.js","../node_modules/@babel/traverse/lib/path/conversion.js","../node_modules/@babel/traverse/lib/path/introspection.js","../node_modules/@babel/traverse/lib/path/context.js","../node_modules/@babel/traverse/lib/path/removal.js","../node_modules/@babel/traverse/lib/path/lib/removal-hooks.js","../node_modules/@babel/traverse/lib/path/modification.js","../node_modules/@babel/traverse/lib/path/lib/hoister.js","../node_modules/@babel/traverse/lib/path/family.js","../node_modules/@babel/traverse/lib/path/comments.js","../node_modules/@babel/traverse/lib/visitors.js","../node_modules/@babel/traverse/lib/hub.js"],"names":["Object","defineProperty","exports","value","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","_t","require","isBinding","isBlockScoped","isExportDeclaration","isExpression","isFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isReferenced","isScope","isStatement","isVar","isVariableDeclaration","isCompatTag","react","types","checkPath","path","opts","node","parent","name","parentPath","grandparent","left","init","isReferencedIdentifier","loc","isUser","scope","isPure","importKind","exportKind","isObjectPattern","isObjectExpression","await","default","_renamer","_index","_binding","_globals","_cache","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","gatherNodeParts","parts","type","source","specifiers","length","declaration","local","push","object","property","callee","properties","argument","key","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","declar","get","getFunctionParent","getProgramParent","registerBinding","Declaration","registerDeclaration","ImportDeclaration","getBlockParent","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","declarations","decl","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","bindings","CatchClause","Function","isFunctionExpression","has","params","param","ClassExpression","uid","this","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","isKey","hub","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","defaultName","join","slice","generateUidBasedOnNode","constant","dontPush","isStatic","generateUidIdentifierBasedOnNode","kind","buildError","TypeError","oldName","newName","rename","map","sep","repeat","console","log","violations","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","label","isLabeledStatement","registerLabel","specifier","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","checkBlockScopedCollisions","registerConstantViolation","constantsOnly","superClass","body","method","right","elements","elem","prop","computed","tag","quasi","expressions","val","crawl","create","programParent","_exploded","enter","visit","typeVisitors","traverse","addGlobal","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","getData","unshiftContainer","setData","declarator","pop","Error","isFunctionParent","isBlockParent","kinds","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","noGlobals","hasOwnBinding","parentHasBinding","hasUid","includes","contextVariables","_this$parent","info","removeOwnBinding","_this$getBinding2","builtin","Binding","referencePaths","referenced","clearValue","hasDeoptedValue","hasValue","indexOf","enumerable","_path","_scope","_hub","visitors","_context","cache","VISITOR_KEYS","removeProperties","traverseFast","noScope","explode","_default","hasDenylistedType","stop","verify","cheap","skipKeys","context","clearNode","delete","tree","hasType","denylistTypes","denylist","SHOULD_SKIP","SHOULD_STOP","REMOVED","virtualTypes","_debug","t","_generator","NodePath_ancestry","NodePath_inference","NodePath_replacement","NodePath_evaluation","NodePath_conversion","NodePath_introspection","NodePath_context","NodePath_removal","NodePath_modification","NodePath_family","NodePath_comments","validate","debug","NodePath","contexts","_traverseFlags","container","listKey","def","undefined","msg","SyntaxError","visitor","inList","message","enabled","getPathLocation","code","v","targetNode","paths","setup","assign","prototype","TYPES","typeKey","fn","virtualType","clear","clearPath","clearScope","WeakMap","TraversalContext","queue","priorityQueue","obj","notPriority","shouldVisit","visitQueue","visited","WeakSet","resync","pushContext","add","popContext","nodes","Array","isArray","visitMultiple","visitSingle","formatArgs","useColors","module","humanize","diff","c","color","splice","index","lastC","match","save","namespaces","storage","setItem","removeItem","error","load","r","getItem","process","DEBUG","window","__nwjs","navigator","userAgent","toLowerCase","document","documentElement","style","WebkitAppearance","firebug","exception","table","parseInt","RegExp","$1","localStorage","localstorage","destroy","warned","warn","colors","formatters","j","JSON","stringify","env","createDebug","prevTime","namespacesCache","enabledCache","enableOverride","self","curr","Number","Date","ms","prev","coerce","format","formatter","call","logFn","apply","selectColor","extend","configurable","delimiter","newDebug","toNamespace","regexp","toString","substring","stack","disable","names","skips","enable","split","len","substr","test","forEach","hash","charCodeAt","Math","abs","s","m","h","d","w","y","plural","msAbs","n","isPlural","round","options","str","String","exec","parseFloat","parse","isFinite","long","fmtLong","fmtShort","_helperSplitExportDeclaration","renameVisitor","assignmentExpression","toExpression","bindingIdentifierEquals","skip","skipKey","skipAllButComputedMethodKey","Renamer","parentDeclar","maybeExportDeclar","find","isDeclaration","isClassExpression","maybeConvertFromExportDeclaration","blockToTraverse","cases","maybeConvertFromClassFunctionDeclaration","maybeConvertFromClassFunctionExpression","findParent","callback","p","getStatementParent","isFile","getEarliestCommonAncestorFrom","getDeepestCommonAncestorFrom","deepest","ancestries","earliest","parentKey","filter","lastCommonIndex","lastCommon","minDepth","Infinity","ancestry","first","depthLoop","shouldMatch","getAncestry","isAncestor","maybeDescendant","isDescendant","maybeAncestor","inType","candidateTypes","getTypeAnnotation","typeAnnotation","_getTypeAnnotation","anyTypeAnnotation","isTypeAnnotation","isVariableDeclarator","declarParent","isForInStatement","stringTypeAnnotation","isForOfStatement","voidTypeAnnotation","typeAnnotationInferringNodes","_inferer","inferer","inferers","validParent","isBaseType","baseName","soft","_isBaseType","couldBeBaseType","isAnyTypeAnnotation","isUnionTypeAnnotation","type2","baseTypeStrictlyMatches","rightArg","isFlowBaseAnnotation","genericName","isGenericTypeAnnotation","isBooleanTypeAnnotation","isEmptyTypeAnnotation","isMixedTypeAnnotation","isNumberTypeAnnotation","isStringTypeAnnotation","isVoidTypeAnnotation","VariableDeclarator","_type","isCallExpression","ArrayExpression","TypeCastExpression","NewExpression","genericTypeAnnotation","TemplateLiteral","NUMBER_UNARY_OPERATORS","numberTypeAnnotation","STRING_UNARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","booleanTypeAnnotation","BinaryExpression","NUMBER_BINARY_OPERATORS","BOOLEAN_BINARY_OPERATORS","unionTypeAnnotation","LogicalExpression","argumentTypes","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","ConditionalExpression","SequenceExpression","ParenthesizedExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","nullLiteralTypeAnnotation","RegExpLiteral","ObjectExpression","RestElement","ClassDeclaration","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","CallExpression","isObjectKeys","arrayTypeAnnotation","isArrayFrom","isObjectValues","isObjectEntries","tupleTypeAnnotation","resolveCall","TaggedTemplateExpression","_infererReference","buildMatchMemberExpression","resolve","is","returnType","functionConstantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","violation","getTypeAnnotationBindingConstantViolations","BOOLEAN_NUMBER_BINARY_OPERATORS","createTypeAnnotationBasedOnTypeof","functions","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","target","typeofPath","typePath","typeValue","isIfStatement","isConditionalExpression","getParentConditionalPath","isLogicalExpression","isBinaryExpression","replaceWithMultiple","_pathCache$get","_verifyNodeList","inheritLeadingComments","inheritTrailingComments","insertAfter","requeue","remove","replaceWithSourceString","replacement","_parser","err","_codeFrame","codeFrameColumns","start","line","column","replaceWith","removed","_index2","nodePath","isNodeType","canHaveVariableDeclarationOrExpression","canSwapBetweenExpressionAndStatement","expressionStatement","replaceExpressionWithStatements","oldNode","inheritsComments","removeComments","_replaceWith","setScope","_pathCache$get2","nodesAsSequenceExpression","toSequenceExpression","functionParent","isParentAsync","isParentGenerator","arrowFunctionExpression","blockStatement","_helperHoistVariables","completionRecords","getCompletionRecords","isExpressionStatement","loop","generateDeclaredUidIdentifier","pushContainer","returnStatement","arrowFunctionToExpression","newCallee","needToAwaitFunction","FUNCTION_TYPES","needToYieldFunction","awaitExpression","yieldExpression","replaceInline","_containerInsertAfter","evaluateTruthy","res","evaluate","confident","deoptPath","seen","evaluateCached","deopt","VALID_CALLEES","INVALID_METHODS","existing","resolved","item","isSequenceExpression","exprs","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","evaluateQuasis","quasis","testResult","isExpressionWrapper","end","NaN","prefix","arg","arr","elems","elemValue","props","isObjectMethod","isSpreadElement","wasConfident","leftConfident","rightConfident","pow","func","global","_evaluate","raw","cooked","expr","toComputedKey","stringLiteral","bodyNode","statements","stringPath","arrowFunctionToShadowed","isArrowFunctionExpression","unwrapFunctionEnvironment","buildCodeFrameError","hoistFunctionEnvironment","allowInsertArrow","specCompliant","noNewArrows","thisBinding","checkBinding","objectExpression","thisExpression","_helperFunctionName","binaryExpression","conditionalExpression","jsxIdentifier","metaProperty","restElement","sequenceExpression","spreadElement","_super","super","fnPath","thisEnvFn","isClassProperty","static","inConstructor","getScopeInformation","thisPaths","argumentsPaths","newTargetPaths","superProps","superCalls","allSuperCalls","child","ClassProperty","superBinding","getSuperBinding","superCall","argumentsBinding","buildUndefinedNode","argumentsChild","argsRef","newTargetBinding","targetChild","targetRef","flatSuperProps","reduce","acc","superProp","concat","standardizeSuperProperty","isAssignment","isAssignmentExpression","isCall","getSuperPropBinding","getThisBinding","hasSuperClass","thisChild","thisRef","isJSX","assignmentPath","op","tmp","isUpdateExpression","updateExpr","computedKey","isClassMethod","supers","argsBinding","propName","fnBody","argsList","valueIdent","cacheKey","ThisExpression","JSXIdentifier","isJSXOpeningElement","MemberExpression","MetaProperty","pattern","allowPartial","_matchesPattern","isnt","equals","isType","isFor","isCompletionRecord","allowInsideFunction","isStatementOrBlock","STATEMENT_OR_BLOCK_KEYS","referencesImport","moduleSource","importName","isOptionalMemberExpression","isImportDefaultSpecifier","isImportNamespaceSpecifier","imported","getSource","getCode","willIMaybeExecuteBefore","funcParent","getOuterFunction","_guessExecutionStatusRelativeToDifferentFunctions","commonPath","commonIndex","isExecutionUncertainInList","divergence","keyPosition","allStatus","executionOrderCheckedNodes","dangerous","_resolve","ret","isTypeCastExpression","targetKey","targetName","isNaN","isConstantExpression","isRegExpLiteral","every","isInStrictMode","sourceType","directives","isExecutionUncertain","maxIndex","_call","fns","then","isBlacklisted","isDenylisted","_this$opts$denylist","blacklist","shouldSkip","shouldStop","getScope","setContext","_resyncParent","_resyncList","_resyncKey","setKey","newContainer","_resyncRemoved","_markRemoved","_this$node","pathToQueue","maybeQueue","_getQueueContexts","_this$opts","_assertUnremoved","_removeFromScope","_callRemovalHooks","shareCommentsWithSiblings","_remove","removeBinding","_removalHooks","hooks","updateSiblingKeys","isWhile","isSwitchCase","insertBefore","nodes_","isJSXElement","_containerInsertBefore","shouldInsertCurrentNode","_containerInsert","from","to","getSibling","assertExpression","temp","fromIndex","incrementBy","verifiedNodes","hoist","hoister","_hoister","run","_t2","jsxExpressionContainer","referenceVisitor","breakOnScopePaths","mutableBinding","PathHoister","scopes","attachAfter","isCompatibleScope","_getAttachmentPath","targetScope","getAttachmentParentForPath","violationPath","hasOwnParamBindings","getNextScopeAttachmentParent","bodies","getCompatibleScopes","attachTo","getAttachmentPath","attached","children","getOpposite","_getCompletionRecords","canHaveBreak","shouldPopulateBreak","inCaseClause","getPrevSibling","getNextSibling","getAllNextSiblings","_key","sibling","siblings","getAllPrevSiblings","_getKey","_getPattern","_","part","duplicates","_getBindingIdentifiers","_getOuterBindingIdentifiers","getBindingIdentifierPaths","outerOnly","search","shift","_ids","getOuterBindingIdentifierPaths","addCompletionRecords","records","normalCompletionToBreak","completions","replaceBreakStatementInBreakCompletion","reachable","isBreakStatement","getStatementListCompletion","lastNormalCompletions","newContext","statementCompletions","some","pathCompletions","isDoExpression","isTryStatement","caseCompletions","normalCompletions","breakCompletions","completionRecordForSwitch","BreakCompletion","NormalCompletion","trailing","trailingComments","leading","leadingComments","next","hasPrev","Boolean","hasNext","addComments","addComment","content","_addComment","comments","_addComments","merge","states","wrapper","rootVisitor","visitorType","wrapWithStateOrWrapper","nodeVisitor","mergePair","DEPRECATED_KEYS","FLIPPED_ALIAS_KEYS","nodeType","shouldIgnoreKey","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapCheck","aliases","deprecatedKey","trace","alias","_verified","validateVisitorMethods","visitorKey","oldVisitor","newVisitor","newFn","arguments","dest","src","Hub"],"mappings":"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","file":"static/js/vendors-runtime-traverse.6603985e.chunk.js","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Binding {\n  constructor({\n    identifier,\n    scope,\n    path,\n    kind\n  }) {\n    this.identifier = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.kind = void 0;\n    this.constantViolations = [];\n    this.constant = true;\n    this.referencePaths = [];\n    this.referenced = false;\n    this.references = 0;\n    this.identifier = identifier;\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n    this.clearValue();\n  }\n\n  deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  }\n\n  setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  }\n\n  clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  }\n\n  reassign(path) {\n    this.constant = false;\n\n    if (this.constantViolations.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.constantViolations.push(path);\n  }\n\n  reference(path) {\n    if (this.referencePaths.indexOf(path) !== -1) {\n      return;\n    }\n\n    this.referenced = true;\n    this.references++;\n    this.referencePaths.push(path);\n  }\n\n  dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  }\n\n}\n\nexports.default = Binding;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"NodePath\", {\n  enumerable: true,\n  get: function () {\n    return _path.default;\n  }\n});\nObject.defineProperty(exports, \"Scope\", {\n  enumerable: true,\n  get: function () {\n    return _scope.default;\n  }\n});\nObject.defineProperty(exports, \"Hub\", {\n  enumerable: true,\n  get: function () {\n    return _hub.default;\n  }\n});\nexports.visitors = exports.default = void 0;\n\nvar _context = require(\"./context\");\n\nvar visitors = require(\"./visitors\");\n\nexports.visitors = visitors;\n\nvar _t = require(\"@babel/types\");\n\nvar cache = require(\"./cache\");\n\nvar _path = require(\"./path\");\n\nvar _scope = require(\"./scope\");\n\nvar _hub = require(\"./hub\");\n\nconst {\n  VISITOR_KEYS,\n  removeProperties,\n  traverseFast\n} = _t;\n\nfunction traverse(parent, opts = {}, scope, state, parentPath) {\n  if (!parent) return;\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(\"You must pass a scope and parentPath unless traversing a Program/File. \" + `Instead of that you tried to traverse a ${parent.type} node without ` + \"passing scope and parentPath.\");\n    }\n  }\n\n  if (!VISITOR_KEYS[parent.type]) {\n    return;\n  }\n\n  visitors.explode(opts);\n  traverse.node(parent, opts, scope, state, parentPath);\n}\n\nvar _default = traverse;\nexports.default = _default;\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\ntraverse.cheap = function (node, enter) {\n  return traverseFast(node, enter);\n};\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  const keys = VISITOR_KEYS[node.type];\n  if (!keys) return;\n  const context = new _context.default(scope, opts, state, parentPath);\n\n  for (const key of keys) {\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\ntraverse.clearNode = function (node, opts) {\n  removeProperties(node, opts);\n  cache.path.delete(node);\n};\n\ntraverse.removeProperties = function (tree, opts) {\n  traverseFast(tree, traverse.clearNode, opts);\n  return tree;\n};\n\nfunction hasDenylistedType(path, state) {\n  if (path.node.type === state.type) {\n    state.has = true;\n    path.stop();\n  }\n}\n\ntraverse.hasType = function (tree, type, denylistTypes) {\n  if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;\n  if (tree.type === type) return true;\n  const state = {\n    has: false,\n    type: type\n  };\n  traverse(tree, {\n    noScope: true,\n    denylist: denylistTypes,\n    enter: hasDenylistedType\n  }, null, state);\n  return state.has;\n};\n\ntraverse.cache = cache;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.SHOULD_SKIP = exports.SHOULD_STOP = exports.REMOVED = void 0;\n\nvar virtualTypes = require(\"./lib/virtual-types\");\n\nvar _debug = require(\"debug\");\n\nvar _index = require(\"../index\");\n\nvar _scope = require(\"../scope\");\n\nvar _t = require(\"@babel/types\");\n\nvar t = _t;\n\nvar _cache = require(\"../cache\");\n\nvar _generator = require(\"@babel/generator\");\n\nvar NodePath_ancestry = require(\"./ancestry\");\n\nvar NodePath_inference = require(\"./inference\");\n\nvar NodePath_replacement = require(\"./replacement\");\n\nvar NodePath_evaluation = require(\"./evaluation\");\n\nvar NodePath_conversion = require(\"./conversion\");\n\nvar NodePath_introspection = require(\"./introspection\");\n\nvar NodePath_context = require(\"./context\");\n\nvar NodePath_removal = require(\"./removal\");\n\nvar NodePath_modification = require(\"./modification\");\n\nvar NodePath_family = require(\"./family\");\n\nvar NodePath_comments = require(\"./comments\");\n\nconst {\n  validate\n} = _t;\n\nconst debug = _debug(\"babel\");\n\nconst REMOVED = 1 << 0;\nexports.REMOVED = REMOVED;\nconst SHOULD_STOP = 1 << 1;\nexports.SHOULD_STOP = SHOULD_STOP;\nconst SHOULD_SKIP = 1 << 2;\nexports.SHOULD_SKIP = SHOULD_SKIP;\n\nclass NodePath {\n  constructor(hub, parent) {\n    this.contexts = [];\n    this.state = null;\n    this.opts = null;\n    this._traverseFlags = 0;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.container = null;\n    this.listKey = null;\n    this.key = null;\n    this.node = null;\n    this.type = null;\n    this.parent = parent;\n    this.hub = hub;\n    this.data = null;\n    this.context = null;\n    this.scope = null;\n  }\n\n  static get({\n    hub,\n    parentPath,\n    parent,\n    container,\n    listKey,\n    key\n  }) {\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    if (!parent) {\n      throw new Error(\"To get a node path the parent needs to exist\");\n    }\n\n    const targetNode = container[key];\n\n    let paths = _cache.path.get(parent);\n\n    if (!paths) {\n      paths = new Map();\n\n      _cache.path.set(parent, paths);\n    }\n\n    let path = paths.get(targetNode);\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      if (targetNode) paths.set(targetNode, path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n    return path;\n  }\n\n  getScope(scope) {\n    return this.isScope() ? new _scope.default(this) : scope;\n  }\n\n  setData(key, val) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    return this.data[key] = val;\n  }\n\n  getData(key, def) {\n    if (this.data == null) {\n      this.data = Object.create(null);\n    }\n\n    let val = this.data[key];\n    if (val === undefined && def !== undefined) val = this.data[key] = def;\n    return val;\n  }\n\n  buildCodeFrameError(msg, Error = SyntaxError) {\n    return this.hub.buildError(this.node, msg, Error);\n  }\n\n  traverse(visitor, state) {\n    (0, _index.default)(this.node, visitor, this.scope, state, this);\n  }\n\n  set(key, node) {\n    validate(this.node, key, node);\n    this.node[key] = node;\n  }\n\n  getPathLocation() {\n    const parts = [];\n    let path = this;\n\n    do {\n      let key = path.key;\n      if (path.inList) key = `${path.listKey}[${key}]`;\n      parts.unshift(key);\n    } while (path = path.parentPath);\n\n    return parts.join(\".\");\n  }\n\n  debug(message) {\n    if (!debug.enabled) return;\n    debug(`${this.getPathLocation()} ${this.type}: ${message}`);\n  }\n\n  toString() {\n    return (0, _generator.default)(this.node).code;\n  }\n\n  get inList() {\n    return !!this.listKey;\n  }\n\n  set inList(inList) {\n    if (!inList) {\n      this.listKey = null;\n    }\n  }\n\n  get parentKey() {\n    return this.listKey || this.key;\n  }\n\n  get shouldSkip() {\n    return !!(this._traverseFlags & SHOULD_SKIP);\n  }\n\n  set shouldSkip(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_SKIP;\n    } else {\n      this._traverseFlags &= ~SHOULD_SKIP;\n    }\n  }\n\n  get shouldStop() {\n    return !!(this._traverseFlags & SHOULD_STOP);\n  }\n\n  set shouldStop(v) {\n    if (v) {\n      this._traverseFlags |= SHOULD_STOP;\n    } else {\n      this._traverseFlags &= ~SHOULD_STOP;\n    }\n  }\n\n  get removed() {\n    return !!(this._traverseFlags & REMOVED);\n  }\n\n  set removed(v) {\n    if (v) {\n      this._traverseFlags |= REMOVED;\n    } else {\n      this._traverseFlags &= ~REMOVED;\n    }\n  }\n\n}\n\nObject.assign(NodePath.prototype, NodePath_ancestry, NodePath_inference, NodePath_replacement, NodePath_evaluation, NodePath_conversion, NodePath_introspection, NodePath_context, NodePath_removal, NodePath_modification, NodePath_family, NodePath_comments);\n\nfor (const type of t.TYPES) {\n  const typeKey = `is${type}`;\n  const fn = t[typeKey];\n\n  NodePath.prototype[typeKey] = function (opts) {\n    return fn(this.node, opts);\n  };\n\n  NodePath.prototype[`assert${type}`] = function (opts) {\n    if (!fn(this.node, opts)) {\n      throw new TypeError(`Expected node path of type ${type}`);\n    }\n  };\n}\n\nfor (const type of Object.keys(virtualTypes)) {\n  if (type[0] === \"_\") continue;\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n  const virtualType = virtualTypes[type];\n\n  NodePath.prototype[`is${type}`] = function (opts) {\n    return virtualType.checkPath(this, opts);\n  };\n}\n\nvar _default = NodePath;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.clear = clear;\nexports.clearPath = clearPath;\nexports.clearScope = clearScope;\nexports.scope = exports.path = void 0;\nlet path = new WeakMap();\nexports.path = path;\nlet scope = new WeakMap();\nexports.scope = scope;\n\nfunction clear() {\n  clearPath();\n  clearScope();\n}\n\nfunction clearPath() {\n  exports.path = path = new WeakMap();\n}\n\nfunction clearScope() {\n  exports.scope = scope = new WeakMap();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _path = require(\"./path\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nclass TraversalContext {\n  constructor(scope, opts, state, parentPath) {\n    this.queue = null;\n    this.priorityQueue = null;\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  shouldVisit(node) {\n    const opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n    if (opts[node.type]) return true;\n    const keys = VISITOR_KEYS[node.type];\n    if (!(keys != null && keys.length)) return false;\n\n    for (const key of keys) {\n      if (node[key]) return true;\n    }\n\n    return false;\n  }\n\n  create(node, obj, key, listKey) {\n    return _path.default.get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey\n    });\n  }\n\n  maybeQueue(path, notPriority) {\n    if (this.queue) {\n      if (notPriority) {\n        this.queue.push(path);\n      } else {\n        this.priorityQueue.push(path);\n      }\n    }\n  }\n\n  visitMultiple(container, parent, listKey) {\n    if (container.length === 0) return false;\n    const queue = [];\n\n    for (let key = 0; key < container.length; key++) {\n      const node = container[key];\n\n      if (node && this.shouldVisit(node)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    return this.visitQueue(queue);\n  }\n\n  visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      return this.visitQueue([this.create(node, node, key)]);\n    } else {\n      return false;\n    }\n  }\n\n  visitQueue(queue) {\n    this.queue = queue;\n    this.priorityQueue = [];\n    const visited = new WeakSet();\n    let stop = false;\n\n    for (const path of queue) {\n      path.resync();\n\n      if (path.contexts.length === 0 || path.contexts[path.contexts.length - 1] !== this) {\n        path.pushContext(this);\n      }\n\n      if (path.key === null) continue;\n      const {\n        node\n      } = path;\n      if (visited.has(node)) continue;\n      if (node) visited.add(node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n\n      if (this.priorityQueue.length) {\n        stop = this.visitQueue(this.priorityQueue);\n        this.priorityQueue = [];\n        this.queue = queue;\n        if (stop) break;\n      }\n    }\n\n    for (const path of queue) {\n      path.popContext();\n    }\n\n    this.queue = null;\n    return stop;\n  }\n\n  visit(node, key) {\n    const nodes = node[key];\n    if (!nodes) return false;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  }\n\n}\n\nexports.default = TraversalContext;","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  VISITOR_KEYS,\n  assignmentExpression,\n  identifier,\n  toExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(variableDeclaration(\"let\", [variableDeclarator(identifier(this.newName), toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: identifier(this.newName)\n    });\n    path.replaceWith(assignmentExpression(\"=\", identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findParent = findParent;\nexports.find = find;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.isAncestor = isAncestor;\nexports.isDescendant = isDescendant;\nexports.inType = inType;\n\nvar _t = require(\"@babel/types\");\n\nvar _index = require(\"./index\");\n\nconst {\n  VISITOR_KEYS\n} = _t;\n\nfunction findParent(callback) {\n  let path = this;\n\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n\n  return null;\n}\n\nfunction find(callback) {\n  let path = this;\n\n  do {\n    if (callback(path)) return path;\n  } while (path = path.parentPath);\n\n  return null;\n}\n\nfunction getFunctionParent() {\n  return this.findParent(p => p.isFunction());\n}\n\nfunction getStatementParent() {\n  let path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    let earliest;\n    const keys = VISITOR_KEYS[deepest.type];\n\n    for (const ancestry of ancestries) {\n      const path = ancestry[i + 1];\n\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      if (path.listKey && earliest.listKey === path.listKey) {\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      const earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      const currentKeyIndex = keys.indexOf(path.parentKey);\n\n      if (earliestKeyIndex > currentKeyIndex) {\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  let minDepth = Infinity;\n  let lastCommonIndex, lastCommon;\n  const ancestries = paths.map(path => {\n    const ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== this);\n\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n  const first = ancestries[0];\n\n  depthLoop: for (let i = 0; i < minDepth; i++) {\n    const shouldMatch = first[i];\n\n    for (const ancestry of ancestries) {\n      if (ancestry[i] !== shouldMatch) {\n        break depthLoop;\n      }\n    }\n\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\nfunction getAncestry() {\n  let path = this;\n  const paths = [];\n\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n\n  return paths;\n}\n\nfunction isAncestor(maybeDescendant) {\n  return maybeDescendant.isDescendant(this);\n}\n\nfunction isDescendant(maybeAncestor) {\n  return !!this.findParent(parent => parent === maybeAncestor);\n}\n\nfunction inType(...candidateTypes) {\n  let path = this;\n\n  while (path) {\n    for (const type of candidateTypes) {\n      if (path.node.type === type) return true;\n    }\n\n    path = path.parentPath;\n  }\n\n  return false;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n\nvar inferers = require(\"./inferers\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  anyTypeAnnotation,\n  isAnyTypeAnnotation,\n  isBooleanTypeAnnotation,\n  isEmptyTypeAnnotation,\n  isFlowBaseAnnotation,\n  isGenericTypeAnnotation,\n  isIdentifier,\n  isMixedTypeAnnotation,\n  isNumberTypeAnnotation,\n  isStringTypeAnnotation,\n  isTypeAnnotation,\n  isUnionTypeAnnotation,\n  isVoidTypeAnnotation,\n  stringTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n  let type = this._getTypeAnnotation() || anyTypeAnnotation();\n  if (isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\nconst typeAnnotationInferringNodes = new WeakSet();\n\nfunction _getTypeAnnotation() {\n  const node = this.node;\n\n  if (!node) {\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      const declar = this.parentPath.parentPath;\n      const declarParent = declar.parentPath;\n\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return stringTypeAnnotation();\n      }\n\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return anyTypeAnnotation();\n      }\n\n      return voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  if (typeAnnotationInferringNodes.has(node)) {\n    return;\n  }\n\n  typeAnnotationInferringNodes.add(node);\n\n  try {\n    var _inferer;\n\n    let inferer = inferers[node.type];\n\n    if (inferer) {\n      return inferer.call(this, node);\n    }\n\n    inferer = inferers[this.parentPath.type];\n\n    if ((_inferer = inferer) != null && _inferer.validParent) {\n      return this.parentPath.getTypeAnnotation();\n    }\n  } finally {\n    typeAnnotationInferringNodes.delete(node);\n  }\n}\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return isMixedTypeAnnotation(type);\n  } else if (baseName === \"empty\") {\n    return isEmptyTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(`Unknown base type ${baseName}`);\n    }\n  }\n}\n\nfunction couldBeBaseType(name) {\n  const type = this.getTypeAnnotation();\n  if (isAnyTypeAnnotation(type)) return true;\n\n  if (isUnionTypeAnnotation(type)) {\n    for (const type2 of type.types) {\n      if (isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\nfunction baseTypeStrictlyMatches(rightArg) {\n  const left = this.getTypeAnnotation();\n  const right = rightArg.getTypeAnnotation();\n\n  if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n\n  return false;\n}\n\nfunction isGenericType(genericName) {\n  const type = this.getTypeAnnotation();\n  return isGenericTypeAnnotation(type) && isIdentifier(type.id, {\n    name: genericName\n  });\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.StringLiteral = StringLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.BooleanLiteral = BooleanLiteral;\nexports.NullLiteral = NullLiteral;\nexports.RegExpLiteral = RegExpLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  BOOLEAN_NUMBER_BINARY_OPERATORS,\n  createFlowUnionType,\n  createTSUnionType,\n  createTypeAnnotationBasedOnTypeof,\n  createUnionTypeAnnotation,\n  isTSTypeAnnotation,\n  numberTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations.push(...functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n    return createTSUnionType(types);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(types);\n  }\n\n  return createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (isTSTypeAnnotation(types[0]) && createTSUnionType) {\n      return {\n        typeAnnotation: createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (createFlowUnionType) {\n      return {\n        typeAnnotation: createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports._replaceWith = _replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n\nvar _codeFrame = require(\"@babel/code-frame\");\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nvar _cache = require(\"../cache\");\n\nvar _parser = require(\"@babel/parser\");\n\nvar _t = require(\"@babel/types\");\n\nvar _helperHoistVariables = require(\"@babel/helper-hoist-variables\");\n\nconst {\n  FUNCTION_TYPES,\n  arrowFunctionExpression,\n  assignmentExpression,\n  awaitExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  identifier,\n  inheritLeadingComments,\n  inheritTrailingComments,\n  inheritsComments,\n  isExpression,\n  isProgram,\n  isStatement,\n  removeComments,\n  returnStatement,\n  toSequenceExpression,\n  validate,\n  yieldExpression\n} = _t;\n\nfunction replaceWithMultiple(nodes) {\n  var _pathCache$get;\n\n  this.resync();\n  nodes = this._verifyNodeList(nodes);\n  inheritLeadingComments(nodes[0], this.node);\n  inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  (_pathCache$get = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get.delete(this.node);\n  this.node = this.container[this.key] = null;\n  const paths = this.insertAfter(nodes);\n\n  if (this.node) {\n    this.requeue();\n  } else {\n    this.remove();\n  }\n\n  return paths;\n}\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = `(${replacement})`;\n    replacement = (0, _parser.parse)(replacement);\n  } catch (err) {\n    const loc = err.loc;\n\n    if (loc) {\n      err.message += \" - make sure this is an expression.\\n\" + (0, _codeFrame.codeFrameColumns)(replacement, {\n        start: {\n          line: loc.line,\n          column: loc.column + 1\n        }\n      });\n      err.code = \"BABEL_REPLACE_SOURCE_ERROR\";\n    }\n\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n\n  _index.default.removeProperties(replacement);\n\n  return this.replaceWith(replacement);\n}\n\nfunction replaceWith(replacement) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index2.default) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.remove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return [this];\n  }\n\n  if (this.isProgram() && !isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  if (Array.isArray(replacement)) {\n    throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n  }\n\n  if (typeof replacement === \"string\") {\n    throw new Error(\"Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`\");\n  }\n\n  let nodePath = \"\";\n\n  if (this.isNodeType(\"Statement\") && isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {\n      replacement = expressionStatement(replacement);\n      nodePath = \"expression\";\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && isStatement(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  const oldNode = this.node;\n\n  if (oldNode) {\n    inheritsComments(replacement, oldNode);\n    removeComments(oldNode);\n  }\n\n  this._replaceWith(replacement);\n\n  this.type = replacement.type;\n  this.setScope();\n  this.requeue();\n  return [nodePath ? this.get(nodePath) : this];\n}\n\nfunction _replaceWith(node) {\n  var _pathCache$get2;\n\n  if (!this.container) {\n    throw new ReferenceError(\"Container is falsy\");\n  }\n\n  if (this.inList) {\n    validate(this.parent, this.key, [node]);\n  } else {\n    validate(this.parent, this.key, node);\n  }\n\n  this.debug(`Replace with ${node == null ? void 0 : node.type}`);\n  (_pathCache$get2 = _cache.path.get(this.parent)) == null ? void 0 : _pathCache$get2.set(node, this).delete(this.node);\n  this.node = this.container[this.key] = node;\n}\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n  const nodesAsSequenceExpression = toSequenceExpression(nodes, this.scope);\n\n  if (nodesAsSequenceExpression) {\n    return this.replaceWith(nodesAsSequenceExpression)[0].get(\"expressions\");\n  }\n\n  const functionParent = this.getFunctionParent();\n  const isParentAsync = functionParent == null ? void 0 : functionParent.is(\"async\");\n  const isParentGenerator = functionParent == null ? void 0 : functionParent.is(\"generator\");\n  const container = arrowFunctionExpression([], blockStatement(nodes));\n  this.replaceWith(callExpression(container, []));\n  const callee = this.get(\"callee\");\n  (0, _helperHoistVariables.default)(callee.get(\"body\"), id => {\n    this.scope.push({\n      id\n    });\n  }, \"var\");\n  const completionRecords = this.get(\"callee\").getCompletionRecords();\n\n  for (const path of completionRecords) {\n    if (!path.isExpressionStatement()) continue;\n    const loop = path.findParent(path => path.isLoop());\n\n    if (loop) {\n      let uid = loop.getData(\"expressionReplacementReturnUid\");\n\n      if (!uid) {\n        uid = callee.scope.generateDeclaredUidIdentifier(\"ret\");\n        callee.get(\"body\").pushContainer(\"body\", returnStatement(cloneNode(uid)));\n        loop.setData(\"expressionReplacementReturnUid\", uid);\n      } else {\n        uid = identifier(uid.name);\n      }\n\n      path.get(\"expression\").replaceWith(assignmentExpression(\"=\", cloneNode(uid), path.node.expression));\n    } else {\n      path.replaceWith(returnStatement(path.node.expression));\n    }\n  }\n\n  callee.arrowFunctionToExpression();\n  const newCallee = callee;\n\n  const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get(\"callee.body\").node, \"AwaitExpression\", FUNCTION_TYPES);\n\n  const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get(\"callee.body\").node, \"YieldExpression\", FUNCTION_TYPES);\n\n  if (needToAwaitFunction) {\n    newCallee.set(\"async\", true);\n\n    if (!needToYieldFunction) {\n      this.replaceWith(awaitExpression(this.node));\n    }\n  }\n\n  if (needToYieldFunction) {\n    newCallee.set(\"generator\", true);\n    this.replaceWith(yieldExpression(this.node, true));\n  }\n\n  return newCallee.get(\"body.body\");\n}\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n\n      const paths = this._containerInsertAfter(nodes);\n\n      this.remove();\n      return paths;\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\nexports.arrowFunctionToShadowed = arrowFunctionToShadowed;\nexports.unwrapFunctionEnvironment = unwrapFunctionEnvironment;\nexports.arrowFunctionToExpression = arrowFunctionToExpression;\n\nvar _t = require(\"@babel/types\");\n\nvar _helperFunctionName = require(\"@babel/helper-function-name\");\n\nconst {\n  arrowFunctionExpression,\n  assignmentExpression,\n  binaryExpression,\n  blockStatement,\n  callExpression,\n  conditionalExpression,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  jsxIdentifier,\n  memberExpression,\n  metaProperty,\n  numericLiteral,\n  objectExpression,\n  restElement,\n  returnStatement,\n  sequenceExpression,\n  spreadElement,\n  stringLiteral,\n  super: _super,\n  thisExpression,\n  unaryExpression\n} = _t;\n\nfunction toComputedKey() {\n  let key;\n\n  if (this.isMemberExpression()) {\n    key = this.node.property;\n  } else if (this.isProperty() || this.isMethod()) {\n    key = this.node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!this.node.computed) {\n    if (isIdentifier(key)) key = stringLiteral(key.name);\n  }\n\n  return key;\n}\n\nfunction ensureBlock() {\n  const body = this.get(\"body\");\n  const bodyNode = body.node;\n\n  if (Array.isArray(body)) {\n    throw new Error(\"Can't convert array path to a block statement\");\n  }\n\n  if (!bodyNode) {\n    throw new Error(\"Can't convert node without a body\");\n  }\n\n  if (body.isBlockStatement()) {\n    return bodyNode;\n  }\n\n  const statements = [];\n  let stringPath = \"body\";\n  let key;\n  let listKey;\n\n  if (body.isStatement()) {\n    listKey = \"body\";\n    key = 0;\n    statements.push(body.node);\n  } else {\n    stringPath += \".body.0\";\n\n    if (this.isFunction()) {\n      key = \"argument\";\n      statements.push(returnStatement(body.node));\n    } else {\n      key = \"expression\";\n      statements.push(expressionStatement(body.node));\n    }\n  }\n\n  this.node.body = blockStatement(statements);\n  const parentPath = this.get(stringPath);\n  body.setup(parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);\n  return this.node;\n}\n\nfunction arrowFunctionToShadowed() {\n  if (!this.isArrowFunctionExpression()) return;\n  this.arrowFunctionToExpression();\n}\n\nfunction unwrapFunctionEnvironment() {\n  if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {\n    throw this.buildCodeFrameError(\"Can only unwrap the environment of a function.\");\n  }\n\n  hoistFunctionEnvironment(this);\n}\n\nfunction arrowFunctionToExpression({\n  allowInsertArrow = true,\n  specCompliant = false,\n  noNewArrows = !specCompliant\n} = {}) {\n  if (!this.isArrowFunctionExpression()) {\n    throw this.buildCodeFrameError(\"Cannot convert non-arrow function to a function expression.\");\n  }\n\n  const thisBinding = hoistFunctionEnvironment(this, noNewArrows, allowInsertArrow);\n  this.ensureBlock();\n  this.node.type = \"FunctionExpression\";\n\n  if (!noNewArrows) {\n    const checkBinding = thisBinding ? null : this.parentPath.scope.generateUidIdentifier(\"arrowCheckId\");\n\n    if (checkBinding) {\n      this.parentPath.scope.push({\n        id: checkBinding,\n        init: objectExpression([])\n      });\n    }\n\n    this.get(\"body\").unshiftContainer(\"body\", expressionStatement(callExpression(this.hub.addHelper(\"newArrowCheck\"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));\n    this.replaceWith(callExpression(memberExpression((0, _helperFunctionName.default)(this, true) || this.node, identifier(\"bind\")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));\n  }\n}\n\nfunction hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true) {\n  const thisEnvFn = fnPath.findParent(p => {\n    return p.isFunction() && !p.isArrowFunctionExpression() || p.isProgram() || p.isClassProperty({\n      static: false\n    });\n  });\n  const inConstructor = (thisEnvFn == null ? void 0 : thisEnvFn.node.kind) === \"constructor\";\n\n  if (thisEnvFn.isClassProperty()) {\n    throw fnPath.buildCodeFrameError(\"Unable to transform arrow inside class property\");\n  }\n\n  const {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  } = getScopeInformation(fnPath);\n\n  if (inConstructor && superCalls.length > 0) {\n    if (!allowInsertArrow) {\n      throw superCalls[0].buildCodeFrameError(\"Unable to handle nested super() usage in arrow\");\n    }\n\n    const allSuperCalls = [];\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        allSuperCalls.push(child);\n      }\n\n    });\n    const superBinding = getSuperBinding(thisEnvFn);\n    allSuperCalls.forEach(superCall => {\n      const callee = identifier(superBinding);\n      callee.loc = superCall.node.callee.loc;\n      superCall.get(\"callee\").replaceWith(callee);\n    });\n  }\n\n  if (argumentsPaths.length > 0) {\n    const argumentsBinding = getBinding(thisEnvFn, \"arguments\", () => {\n      const args = () => identifier(\"arguments\");\n\n      if (thisEnvFn.scope.path.isProgram()) {\n        return conditionalExpression(binaryExpression(\"===\", unaryExpression(\"typeof\", args()), stringLiteral(\"undefined\")), thisEnvFn.scope.buildUndefinedNode(), args());\n      } else {\n        return args();\n      }\n    });\n    argumentsPaths.forEach(argumentsChild => {\n      const argsRef = identifier(argumentsBinding);\n      argsRef.loc = argumentsChild.node.loc;\n      argumentsChild.replaceWith(argsRef);\n    });\n  }\n\n  if (newTargetPaths.length > 0) {\n    const newTargetBinding = getBinding(thisEnvFn, \"newtarget\", () => metaProperty(identifier(\"new\"), identifier(\"target\")));\n    newTargetPaths.forEach(targetChild => {\n      const targetRef = identifier(newTargetBinding);\n      targetRef.loc = targetChild.node.loc;\n      targetChild.replaceWith(targetRef);\n    });\n  }\n\n  if (superProps.length > 0) {\n    if (!allowInsertArrow) {\n      throw superProps[0].buildCodeFrameError(\"Unable to handle nested super.prop usage\");\n    }\n\n    const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);\n    flatSuperProps.forEach(superProp => {\n      const key = superProp.node.computed ? \"\" : superProp.get(\"property\").node.name;\n      const isAssignment = superProp.parentPath.isAssignmentExpression({\n        left: superProp.node\n      });\n      const isCall = superProp.parentPath.isCallExpression({\n        callee: superProp.node\n      });\n      const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);\n      const args = [];\n\n      if (superProp.node.computed) {\n        args.push(superProp.get(\"property\").node);\n      }\n\n      if (isAssignment) {\n        const value = superProp.parentPath.node.right;\n        args.push(value);\n      }\n\n      const call = callExpression(identifier(superBinding), args);\n\n      if (isCall) {\n        superProp.parentPath.unshiftContainer(\"arguments\", thisExpression());\n        superProp.replaceWith(memberExpression(call, identifier(\"call\")));\n        thisPaths.push(superProp.parentPath.get(\"arguments.0\"));\n      } else if (isAssignment) {\n        superProp.parentPath.replaceWith(call);\n      } else {\n        superProp.replaceWith(call);\n      }\n    });\n  }\n\n  let thisBinding;\n\n  if (thisPaths.length > 0 || !noNewArrows) {\n    thisBinding = getThisBinding(thisEnvFn, inConstructor);\n\n    if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {\n      thisPaths.forEach(thisChild => {\n        const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);\n        thisRef.loc = thisChild.node.loc;\n        thisChild.replaceWith(thisRef);\n      });\n      if (!noNewArrows) thisBinding = null;\n    }\n  }\n\n  return thisBinding;\n}\n\nfunction standardizeSuperProperty(superProp) {\n  if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== \"=\") {\n    const assignmentPath = superProp.parentPath;\n    const op = assignmentPath.node.operator.slice(0, -1);\n    const value = assignmentPath.node.right;\n    assignmentPath.node.operator = \"=\";\n\n    if (superProp.node.computed) {\n      const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, assignmentExpression(\"=\", tmp, superProp.node.property), true));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(tmp.name), true), value));\n    } else {\n      assignmentPath.get(\"left\").replaceWith(memberExpression(superProp.node.object, superProp.node.property));\n      assignmentPath.get(\"right\").replaceWith(binaryExpression(op, memberExpression(superProp.node.object, identifier(superProp.node.property.name)), value));\n    }\n\n    return [assignmentPath.get(\"left\"), assignmentPath.get(\"right\").get(\"left\")];\n  } else if (superProp.parentPath.isUpdateExpression()) {\n    const updateExpr = superProp.parentPath;\n    const tmp = superProp.scope.generateDeclaredUidIdentifier(\"tmp\");\n    const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier(\"prop\") : null;\n    const parts = [assignmentExpression(\"=\", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression(\"=\", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression(\"=\", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(\"+\", identifier(tmp.name), numericLiteral(1)))];\n\n    if (!superProp.parentPath.node.prefix) {\n      parts.push(identifier(tmp.name));\n    }\n\n    updateExpr.replaceWith(sequenceExpression(parts));\n    const left = updateExpr.get(\"expressions.0.right\");\n    const right = updateExpr.get(\"expressions.1.left\");\n    return [left, right];\n  }\n\n  return [superProp];\n}\n\nfunction hasSuperClass(thisEnvFn) {\n  return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;\n}\n\nfunction getThisBinding(thisEnvFn, inConstructor) {\n  return getBinding(thisEnvFn, \"this\", thisBinding => {\n    if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();\n    const supers = new WeakSet();\n    thisEnvFn.traverse({\n      Function(child) {\n        if (child.isArrowFunctionExpression()) return;\n        child.skip();\n      },\n\n      ClassProperty(child) {\n        child.skip();\n      },\n\n      CallExpression(child) {\n        if (!child.get(\"callee\").isSuper()) return;\n        if (supers.has(child.node)) return;\n        supers.add(child.node);\n        child.replaceWithMultiple([child.node, assignmentExpression(\"=\", identifier(thisBinding), identifier(\"this\"))]);\n      }\n\n    });\n  });\n}\n\nfunction getSuperBinding(thisEnvFn) {\n  return getBinding(thisEnvFn, \"supercall\", () => {\n    const argsBinding = thisEnvFn.scope.generateUidIdentifier(\"args\");\n    return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));\n  });\n}\n\nfunction getSuperPropBinding(thisEnvFn, isAssignment, propName) {\n  const op = isAssignment ? \"set\" : \"get\";\n  return getBinding(thisEnvFn, `superprop_${op}:${propName || \"\"}`, () => {\n    const argsList = [];\n    let fnBody;\n\n    if (propName) {\n      fnBody = memberExpression(_super(), identifier(propName));\n    } else {\n      const method = thisEnvFn.scope.generateUidIdentifier(\"prop\");\n      argsList.unshift(method);\n      fnBody = memberExpression(_super(), identifier(method.name), true);\n    }\n\n    if (isAssignment) {\n      const valueIdent = thisEnvFn.scope.generateUidIdentifier(\"value\");\n      argsList.push(valueIdent);\n      fnBody = assignmentExpression(\"=\", fnBody, identifier(valueIdent.name));\n    }\n\n    return arrowFunctionExpression(argsList, fnBody);\n  });\n}\n\nfunction getBinding(thisEnvFn, key, init) {\n  const cacheKey = \"binding:\" + key;\n  let data = thisEnvFn.getData(cacheKey);\n\n  if (!data) {\n    const id = thisEnvFn.scope.generateUidIdentifier(key);\n    data = id.name;\n    thisEnvFn.setData(cacheKey, data);\n    thisEnvFn.scope.push({\n      id: id,\n      init: init(data)\n    });\n  }\n\n  return data;\n}\n\nfunction getScopeInformation(fnPath) {\n  const thisPaths = [];\n  const argumentsPaths = [];\n  const newTargetPaths = [];\n  const superProps = [];\n  const superCalls = [];\n  fnPath.traverse({\n    ClassProperty(child) {\n      child.skip();\n    },\n\n    Function(child) {\n      if (child.isArrowFunctionExpression()) return;\n      child.skip();\n    },\n\n    ThisExpression(child) {\n      thisPaths.push(child);\n    },\n\n    JSXIdentifier(child) {\n      if (child.node.name !== \"this\") return;\n\n      if (!child.parentPath.isJSXMemberExpression({\n        object: child.node\n      }) && !child.parentPath.isJSXOpeningElement({\n        name: child.node\n      })) {\n        return;\n      }\n\n      thisPaths.push(child);\n    },\n\n    CallExpression(child) {\n      if (child.get(\"callee\").isSuper()) superCalls.push(child);\n    },\n\n    MemberExpression(child) {\n      if (child.get(\"object\").isSuper()) superProps.push(child);\n    },\n\n    ReferencedIdentifier(child) {\n      if (child.node.name !== \"arguments\") return;\n      let curr = child.scope;\n\n      do {\n        if (curr.hasOwnBinding(\"arguments\")) {\n          curr.rename(\"arguments\");\n          return;\n        }\n\n        if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (curr = curr.parent);\n\n      argumentsPaths.push(child);\n    },\n\n    MetaProperty(child) {\n      if (!child.get(\"meta\").isIdentifier({\n        name: \"new\"\n      })) return;\n      if (!child.get(\"property\").isIdentifier({\n        name: \"target\"\n      })) return;\n      newTargetPaths.push(child);\n    }\n\n  });\n  return {\n    thisPaths,\n    argumentsPaths,\n    newTargetPaths,\n    superProps,\n    superCalls\n  };\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isStatic = isStatic;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports._guessExecutionStatusRelativeToDifferentFunctions = _guessExecutionStatusRelativeToDifferentFunctions;\nexports.resolve = resolve;\nexports._resolve = _resolve;\nexports.isConstantExpression = isConstantExpression;\nexports.isInStrictMode = isInStrictMode;\nexports.is = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  STATEMENT_OR_BLOCK_KEYS,\n  VISITOR_KEYS,\n  isBlockStatement,\n  isExpression,\n  isIdentifier,\n  isLiteral,\n  isStringLiteral,\n  isType,\n  matchesPattern: _matchesPattern\n} = _t;\n\nfunction matchesPattern(pattern, allowPartial) {\n  return _matchesPattern(this.node, pattern, allowPartial);\n}\n\nfunction has(key) {\n  const val = this.node && this.node[key];\n\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\nfunction isStatic() {\n  return this.scope.isStatic(this.node);\n}\n\nconst is = has;\nexports.is = is;\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\nfunction isNodeType(type) {\n  return isType(this.type, type);\n}\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return isExpression(replacement);\n  }\n\n  return false;\n}\n\nfunction isCompletionRecord(allowInsideFunction) {\n  let path = this;\n  let first = true;\n\n  do {\n    const container = path.container;\n\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return STATEMENT_OR_BLOCK_KEYS.includes(this.key);\n  }\n}\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) {\n    if ((this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {\n      value: importName\n    }) : this.node.property.name === importName)) {\n      const object = this.get(\"object\");\n      return object.isReferencedIdentifier() && object.referencesImport(moduleSource, \"*\");\n    }\n\n    return false;\n  }\n\n  const binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n  const path = binding.path;\n  const parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && isIdentifier(path.node.imported, {\n    name: importName\n  })) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction getSource() {\n  const node = this.node;\n\n  if (node.end) {\n    const code = this.hub.getCode();\n    if (code) return code.slice(node.start, node.end);\n  }\n\n  return \"\";\n}\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\nfunction getOuterFunction(path) {\n  return (path.scope.getFunctionParent() || path.scope.getProgramParent()).path;\n}\n\nfunction isExecutionUncertain(type, key) {\n  switch (type) {\n    case \"LogicalExpression\":\n      return key === \"right\";\n\n    case \"ConditionalExpression\":\n    case \"IfStatement\":\n      return key === \"consequent\" || key === \"alternate\";\n\n    case \"WhileStatement\":\n    case \"DoWhileStatement\":\n    case \"ForInStatement\":\n    case \"ForOfStatement\":\n      return key === \"body\";\n\n    case \"ForStatement\":\n      return key === \"body\" || key === \"update\";\n\n    case \"SwitchStatement\":\n      return key === \"cases\";\n\n    case \"TryStatement\":\n      return key === \"handler\";\n\n    case \"AssignmentPattern\":\n      return key === \"right\";\n\n    case \"OptionalMemberExpression\":\n      return key === \"property\";\n\n    case \"OptionalCallExpression\":\n      return key === \"arguments\";\n\n    default:\n      return false;\n  }\n}\n\nfunction isExecutionUncertainInList(paths, maxIndex) {\n  for (let i = 0; i < maxIndex; i++) {\n    const path = paths[i];\n\n    if (isExecutionUncertain(path.parent.type, path.parentKey)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  const funcParent = {\n    this: getOuterFunction(this),\n    target: getOuterFunction(target)\n  };\n\n  if (funcParent.target.node !== funcParent.this.node) {\n    return this._guessExecutionStatusRelativeToDifferentFunctions(funcParent.target);\n  }\n\n  const paths = {\n    target: target.getAncestry(),\n    this: this.getAncestry()\n  };\n  if (paths.target.indexOf(this) >= 0) return \"after\";\n  if (paths.this.indexOf(target) >= 0) return \"before\";\n  let commonPath;\n  const commonIndex = {\n    target: 0,\n    this: 0\n  };\n\n  while (!commonPath && commonIndex.this < paths.this.length) {\n    const path = paths.this[commonIndex.this];\n    commonIndex.target = paths.target.indexOf(path);\n\n    if (commonIndex.target >= 0) {\n      commonPath = path;\n    } else {\n      commonIndex.this++;\n    }\n  }\n\n  if (!commonPath) {\n    throw new Error(\"Internal Babel error - The two compared nodes\" + \" don't appear to belong to the same program.\");\n  }\n\n  if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {\n    return \"unknown\";\n  }\n\n  const divergence = {\n    this: paths.this[commonIndex.this - 1],\n    target: paths.target[commonIndex.target - 1]\n  };\n\n  if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {\n    return divergence.target.key > divergence.this.key ? \"before\" : \"after\";\n  }\n\n  const keys = VISITOR_KEYS[commonPath.type];\n  const keyPosition = {\n    this: keys.indexOf(divergence.this.parentKey),\n    target: keys.indexOf(divergence.target.parentKey)\n  };\n  return keyPosition.target > keyPosition.this ? \"before\" : \"after\";\n}\n\nconst executionOrderCheckedNodes = new WeakSet();\n\nfunction _guessExecutionStatusRelativeToDifferentFunctions(target) {\n  if (!target.isFunctionDeclaration() || target.parentPath.isExportDeclaration()) {\n    return \"unknown\";\n  }\n\n  const binding = target.scope.getBinding(target.node.id.name);\n  if (!binding.references) return \"before\";\n  const referencePaths = binding.referencePaths;\n  let allStatus;\n\n  for (const path of referencePaths) {\n    const childOfFunction = !!path.find(path => path.node === target.node);\n    if (childOfFunction) continue;\n\n    if (path.key !== \"callee\" || !path.parentPath.isCallExpression()) {\n      return \"unknown\";\n    }\n\n    if (executionOrderCheckedNodes.has(path.node)) continue;\n    executionOrderCheckedNodes.add(path.node);\n\n    const status = this._guessExecutionStatusRelativeTo(path);\n\n    executionOrderCheckedNodes.delete(path.node);\n\n    if (allStatus && allStatus !== status) {\n      return \"unknown\";\n    } else {\n      allStatus = status;\n    }\n  }\n\n  return allStatus;\n}\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\nfunction _resolve(dangerous, resolved) {\n  if (resolved && resolved.indexOf(this) >= 0) return;\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {}\n  } else if (this.isReferencedIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return;\n    if (!binding.constant) return;\n    if (binding.kind === \"module\") return;\n\n    if (binding.path !== this) {\n      const ret = binding.path.resolve(dangerous, resolved);\n      if (this.find(parent => parent.node === ret.node)) return;\n      return ret;\n    }\n  } else if (this.isTypeCastExpression()) {\n    return this.get(\"expression\").resolve(dangerous, resolved);\n  } else if (dangerous && this.isMemberExpression()) {\n    const targetKey = this.toComputedKey();\n    if (!isLiteral(targetKey)) return;\n    const targetName = targetKey.value;\n    const target = this.get(\"object\").resolve(dangerous, resolved);\n\n    if (target.isObjectExpression()) {\n      const props = target.get(\"properties\");\n\n      for (const prop of props) {\n        if (!prop.isProperty()) continue;\n        const key = prop.get(\"key\");\n        let match = prop.isnt(\"computed\") && key.isIdentifier({\n          name: targetName\n        });\n        match = match || key.isLiteral({\n          value: targetName\n        });\n        if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n      }\n    } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n      const elems = target.get(\"elements\");\n      const elem = elems[targetName];\n      if (elem) return elem.resolve(dangerous, resolved);\n    }\n  }\n}\n\nfunction isConstantExpression() {\n  if (this.isIdentifier()) {\n    const binding = this.scope.getBinding(this.node.name);\n    if (!binding) return false;\n    return binding.constant;\n  }\n\n  if (this.isLiteral()) {\n    if (this.isRegExpLiteral()) {\n      return false;\n    }\n\n    if (this.isTemplateLiteral()) {\n      return this.get(\"expressions\").every(expression => expression.isConstantExpression());\n    }\n\n    return true;\n  }\n\n  if (this.isUnaryExpression()) {\n    if (this.node.operator !== \"void\") {\n      return false;\n    }\n\n    return this.get(\"argument\").isConstantExpression();\n  }\n\n  if (this.isBinaryExpression()) {\n    return this.get(\"left\").isConstantExpression() && this.get(\"right\").isConstantExpression();\n  }\n\n  return false;\n}\n\nfunction isInStrictMode() {\n  const start = this.isProgram() ? this : this.parentPath;\n  const strictParent = start.find(path => {\n    if (path.isProgram({\n      sourceType: \"module\"\n    })) return true;\n    if (path.isClass()) return true;\n    if (!path.isProgram() && !path.isFunction()) return false;\n\n    if (path.isArrowFunctionExpression() && !path.get(\"body\").isBlockStatement()) {\n      return false;\n    }\n\n    const body = path.isFunction() ? path.node.body : path.node;\n\n    for (const directive of body.directives) {\n      if (directive.value.value === \"use strict\") {\n        return true;\n      }\n    }\n  });\n  return !!strictParent;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports._call = _call;\nexports.isBlacklisted = exports.isDenylisted = isDenylisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.popContext = popContext;\nexports.pushContext = pushContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.requeue = requeue;\nexports._getQueueContexts = _getQueueContexts;\n\nvar _index = require(\"../index\");\n\nvar _index2 = require(\"./index\");\n\nfunction call(key) {\n  const opts = this.opts;\n  this.debug(key);\n\n  if (this.node) {\n    if (this._call(opts[key])) return true;\n  }\n\n  if (this.node) {\n    return this._call(opts[this.node.type] && opts[this.node.type][key]);\n  }\n\n  return false;\n}\n\nfunction _call(fns) {\n  if (!fns) return false;\n\n  for (const fn of fns) {\n    if (!fn) continue;\n    const node = this.node;\n    if (!node) return true;\n    const ret = fn.call(this.state, this, this.state);\n\n    if (ret && typeof ret === \"object\" && typeof ret.then === \"function\") {\n      throw new Error(`You appear to be using a plugin with an async traversal visitor, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, you may need to upgrade ` + `your @babel/core version.`);\n    }\n\n    if (ret) {\n      throw new Error(`Unexpected return value from visitor method ${fn}`);\n    }\n\n    if (this.node !== node) return true;\n    if (this._traverseFlags > 0) return true;\n  }\n\n  return false;\n}\n\nfunction isDenylisted() {\n  var _this$opts$denylist;\n\n  const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;\n  return denylist && denylist.indexOf(this.node.type) > -1;\n}\n\nfunction visit() {\n  if (!this.node) {\n    return false;\n  }\n\n  if (this.isDenylisted()) {\n    return false;\n  }\n\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) {\n    return false;\n  }\n\n  if (this.shouldSkip || this.call(\"enter\") || this.shouldSkip) {\n    this.debug(\"Skip...\");\n    return this.shouldStop;\n  }\n\n  this.debug(\"Recursing into...\");\n\n  _index.default.node(this.node, this.opts, this.scope, this.state, this, this.skipKeys);\n\n  this.call(\"exit\");\n  return this.shouldStop;\n}\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\nfunction skipKey(key) {\n  if (this.skipKeys == null) {\n    this.skipKeys = {};\n  }\n\n  this.skipKeys[key] = true;\n}\n\nfunction stop() {\n  this._traverseFlags |= _index2.SHOULD_SKIP | _index2.SHOULD_STOP;\n}\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n  let path = this.parentPath;\n  if (this.key === \"key\" && path.isMethod()) path = path.parentPath;\n  let target;\n\n  while (path && !target) {\n    if (path.opts && path.opts.noScope) return;\n    target = path.scope;\n    path = path.parentPath;\n  }\n\n  this.scope = this.getScope(target);\n  if (this.scope) this.scope.init();\n}\n\nfunction setContext(context) {\n  if (this.skipKeys != null) {\n    this.skipKeys = {};\n  }\n\n  this._traverseFlags = 0;\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n  return this;\n}\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n\n  this._resyncList();\n\n  this._resyncKey();\n}\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\nfunction _resyncKey() {\n  if (!this.container) return;\n  if (this.node === this.container[this.key]) return;\n\n  if (Array.isArray(this.container)) {\n    for (let i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (const key of Object.keys(this.container)) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\nfunction _resyncList() {\n  if (!this.parent || !this.inList) return;\n  const newContainer = this.parent[this.listKey];\n  if (this.container === newContainer) return;\n  this.container = newContainer || null;\n}\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\nfunction popContext() {\n  this.contexts.pop();\n\n  if (this.contexts.length > 0) {\n    this.setContext(this.contexts[this.contexts.length - 1]);\n  } else {\n    this.setContext(undefined);\n  }\n}\n\nfunction pushContext(context) {\n  this.contexts.push(context);\n  this.setContext(context);\n}\n\nfunction setup(parentPath, container, listKey, key) {\n  this.listKey = listKey;\n  this.container = container;\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\nfunction setKey(key) {\n  var _this$node;\n\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;\n}\n\nfunction requeue(pathToQueue = this) {\n  if (pathToQueue.removed) return;\n  ;\n  const contexts = this.contexts;\n\n  for (const context of contexts) {\n    context.maybeQueue(pathToQueue);\n  }\n}\n\nfunction _getQueueContexts() {\n  let path = this;\n  let contexts = this.contexts;\n\n  while (!contexts.length) {\n    path = path.parentPath;\n    if (!path) break;\n    contexts = path.contexts;\n  }\n\n  return contexts;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nexports._removeFromScope = _removeFromScope;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n\nvar _removalHooks = require(\"./lib/removal-hooks\");\n\nvar _cache = require(\"../cache\");\n\nvar _index = require(\"./index\");\n\nfunction remove() {\n  var _this$opts;\n\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {\n    this._removeFromScope();\n  }\n\n  if (this._callRemovalHooks()) {\n    this._markRemoved();\n\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n\n  this._remove();\n\n  this._markRemoved();\n}\n\nfunction _removeFromScope() {\n  const bindings = this.getBindingIdentifiers();\n  Object.keys(bindings).forEach(name => this.scope.removeBinding(name));\n}\n\nfunction _callRemovalHooks() {\n  for (const fn of _removalHooks.hooks) {\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this._replaceWith(null);\n  }\n}\n\nfunction _markRemoved() {\n  this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;\n  if (this.parent) _cache.path.get(this.parent).delete(this.node);\n  this.node = null;\n}\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.buildCodeFrameError(\"NodePath has been removed so is read-only.\");\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hooks = void 0;\nconst hooks = [function (self, parent) {\n  const removeParent = self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase()) || self.key === \"declaration\" && parent.isExportDeclaration() || self.key === \"body\" && parent.isLabeledStatement() || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self.key === \"expression\" && parent.isExpressionStatement();\n\n  if (removeParent) {\n    parent.remove();\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isBinary()) {\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      parent.replaceWith(parent.node.left);\n    }\n\n    return true;\n  }\n}, function (self, parent) {\n  if (parent.isIfStatement() && (self.key === \"consequent\" || self.key === \"alternate\") || self.key === \"body\" && (parent.isLoop() || parent.isArrowFunctionExpression())) {\n    self.replaceWith({\n      type: \"BlockStatement\",\n      body: []\n    });\n    return true;\n  }\n}];\nexports.hooks = hooks;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n      nodes.push(expressionStatement(cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.getPrevSibling = getPrevSibling;\nexports.getNextSibling = getNextSibling;\nexports.getAllNextSiblings = getAllNextSiblings;\nexports.getAllPrevSiblings = getAllPrevSiblings;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\nexports.getOuterBindingIdentifiers = getOuterBindingIdentifiers;\nexports.getBindingIdentifierPaths = getBindingIdentifierPaths;\nexports.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  getBindingIdentifiers: _getBindingIdentifiers,\n  getOuterBindingIdentifiers: _getOuterBindingIdentifiers,\n  isDeclaration,\n  numericLiteral,\n  unaryExpression\n} = _t;\nconst NORMAL_COMPLETION = 0;\nconst BREAK_COMPLETION = 1;\n\nfunction NormalCompletion(path) {\n  return {\n    type: NORMAL_COMPLETION,\n    path\n  };\n}\n\nfunction BreakCompletion(path) {\n  return {\n    type: BREAK_COMPLETION,\n    path\n  };\n}\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n\n  return null;\n}\n\nfunction addCompletionRecords(path, records, context) {\n  if (path) {\n    records.push(..._getCompletionRecords(path, context));\n  }\n\n  return records;\n}\n\nfunction completionRecordForSwitch(cases, records, context) {\n  let lastNormalCompletions = [];\n\n  for (let i = 0; i < cases.length; i++) {\n    const casePath = cases[i];\n\n    const caseCompletions = _getCompletionRecords(casePath, context);\n\n    const normalCompletions = [];\n    const breakCompletions = [];\n\n    for (const c of caseCompletions) {\n      if (c.type === NORMAL_COMPLETION) {\n        normalCompletions.push(c);\n      }\n\n      if (c.type === BREAK_COMPLETION) {\n        breakCompletions.push(c);\n      }\n    }\n\n    if (normalCompletions.length) {\n      lastNormalCompletions = normalCompletions;\n    }\n\n    records.push(...breakCompletions);\n  }\n\n  records.push(...lastNormalCompletions);\n  return records;\n}\n\nfunction normalCompletionToBreak(completions) {\n  completions.forEach(c => {\n    c.type = BREAK_COMPLETION;\n  });\n}\n\nfunction replaceBreakStatementInBreakCompletion(completions, reachable) {\n  completions.forEach(c => {\n    if (c.path.isBreakStatement({\n      label: null\n    })) {\n      if (reachable) {\n        c.path.replaceWith(unaryExpression(\"void\", numericLiteral(0)));\n      } else {\n        c.path.remove();\n      }\n    }\n  });\n}\n\nfunction getStatementListCompletion(paths, context) {\n  const completions = [];\n\n  if (context.canHaveBreak) {\n    let lastNormalCompletions = [];\n\n    for (let i = 0; i < paths.length; i++) {\n      const path = paths[i];\n      const newContext = Object.assign({}, context, {\n        inCaseClause: false\n      });\n\n      if (path.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {\n        newContext.shouldPopulateBreak = true;\n      } else {\n        newContext.shouldPopulateBreak = false;\n      }\n\n      const statementCompletions = _getCompletionRecords(path, newContext);\n\n      if (statementCompletions.length > 0 && statementCompletions.every(c => c.type === BREAK_COMPLETION)) {\n        if (lastNormalCompletions.length > 0 && statementCompletions.every(c => c.path.isBreakStatement({\n          label: null\n        }))) {\n          normalCompletionToBreak(lastNormalCompletions);\n          completions.push(...lastNormalCompletions);\n\n          if (lastNormalCompletions.some(c => c.path.isDeclaration())) {\n            completions.push(...statementCompletions);\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n\n          replaceBreakStatementInBreakCompletion(statementCompletions, false);\n        } else {\n          completions.push(...statementCompletions);\n\n          if (!context.shouldPopulateBreak) {\n            replaceBreakStatementInBreakCompletion(statementCompletions, true);\n          }\n        }\n\n        break;\n      }\n\n      if (i === paths.length - 1) {\n        completions.push(...statementCompletions);\n      } else {\n        lastNormalCompletions = [];\n\n        for (let i = 0; i < statementCompletions.length; i++) {\n          const c = statementCompletions[i];\n\n          if (c.type === BREAK_COMPLETION) {\n            completions.push(c);\n          }\n\n          if (c.type === NORMAL_COMPLETION) {\n            lastNormalCompletions.push(c);\n          }\n        }\n      }\n    }\n  } else if (paths.length) {\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const pathCompletions = _getCompletionRecords(paths[i], context);\n\n      if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {\n        completions.push(...pathCompletions);\n        break;\n      }\n    }\n  }\n\n  return completions;\n}\n\nfunction _getCompletionRecords(path, context) {\n  let records = [];\n\n  if (path.isIfStatement()) {\n    records = addCompletionRecords(path.get(\"consequent\"), records, context);\n    records = addCompletionRecords(path.get(\"alternate\"), records, context);\n  } else if (path.isDoExpression() || path.isFor() || path.isWhile() || path.isLabeledStatement()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isProgram() || path.isBlockStatement()) {\n    return getStatementListCompletion(path.get(\"body\"), context);\n  } else if (path.isFunction()) {\n    return _getCompletionRecords(path.get(\"body\"), context);\n  } else if (path.isTryStatement()) {\n    records = addCompletionRecords(path.get(\"block\"), records, context);\n    records = addCompletionRecords(path.get(\"handler\"), records, context);\n  } else if (path.isCatchClause()) {\n    return addCompletionRecords(path.get(\"body\"), records, context);\n  } else if (path.isSwitchStatement()) {\n    return completionRecordForSwitch(path.get(\"cases\"), records, context);\n  } else if (path.isSwitchCase()) {\n    return getStatementListCompletion(path.get(\"consequent\"), {\n      canHaveBreak: true,\n      shouldPopulateBreak: false,\n      inCaseClause: true\n    });\n  } else if (path.isBreakStatement()) {\n    records.push(BreakCompletion(path));\n  } else {\n    records.push(NormalCompletion(path));\n  }\n\n  return records;\n}\n\nfunction getCompletionRecords() {\n  const records = _getCompletionRecords(this, {\n    canHaveBreak: false,\n    shouldPopulateBreak: false,\n    inCaseClause: false\n  });\n\n  return records.map(r => r.path);\n}\n\nfunction getSibling(key) {\n  return _index.default.get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  }).setContext(this.context);\n}\n\nfunction getPrevSibling() {\n  return this.getSibling(this.key - 1);\n}\n\nfunction getNextSibling() {\n  return this.getSibling(this.key + 1);\n}\n\nfunction getAllNextSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(++_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(++_key);\n  }\n\n  return siblings;\n}\n\nfunction getAllPrevSiblings() {\n  let _key = this.key;\n  let sibling = this.getSibling(--_key);\n  const siblings = [];\n\n  while (sibling.node) {\n    siblings.push(sibling);\n    sibling = this.getSibling(--_key);\n  }\n\n  return siblings;\n}\n\nfunction get(key, context = true) {\n  if (context === true) context = this.context;\n  const parts = key.split(\".\");\n\n  if (parts.length === 1) {\n    return this._getKey(key, context);\n  } else {\n    return this._getPattern(parts, context);\n  }\n}\n\nfunction _getKey(key, context) {\n  const node = this.node;\n  const container = node[key];\n\n  if (Array.isArray(container)) {\n    return container.map((_, i) => {\n      return _index.default.get({\n        listKey: key,\n        parentPath: this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index.default.get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\nfunction _getPattern(parts, context) {\n  let path = this;\n\n  for (const part of parts) {\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n\n  return path;\n}\n\nfunction getBindingIdentifiers(duplicates) {\n  return _getBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getOuterBindingIdentifiers(duplicates) {\n  return _getOuterBindingIdentifiers(this.node, duplicates);\n}\n\nfunction getBindingIdentifierPaths(duplicates = false, outerOnly = false) {\n  const path = this;\n  const search = [path];\n  const ids = Object.create(null);\n\n  while (search.length) {\n    const id = search.shift();\n    if (!id) continue;\n    if (!id.node) continue;\n    const keys = _getBindingIdentifiers.keys[id.node.type];\n\n    if (id.isIdentifier()) {\n      if (duplicates) {\n        const _ids = ids[id.node.name] = ids[id.node.name] || [];\n\n        _ids.push(id);\n      } else {\n        ids[id.node.name] = id;\n      }\n\n      continue;\n    }\n\n    if (id.isExportDeclaration()) {\n      const declaration = id.get(\"declaration\");\n\n      if (isDeclaration(declaration)) {\n        search.push(declaration);\n      }\n\n      continue;\n    }\n\n    if (outerOnly) {\n      if (id.isFunctionDeclaration()) {\n        search.push(id.get(\"id\"));\n        continue;\n      }\n\n      if (id.isFunctionExpression()) {\n        continue;\n      }\n    }\n\n    if (keys) {\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        const child = id.get(key);\n\n        if (Array.isArray(child)) {\n          search.push(...child);\n        } else if (child.node) {\n          search.push(child);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\nfunction getOuterBindingIdentifierPaths(duplicates) {\n  return this.getBindingIdentifierPaths(duplicates, true);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  addComment: _addComment,\n  addComments: _addComments\n} = _t;\n\nfunction shareCommentsWithSiblings() {\n  if (typeof this.key === \"string\") return;\n  const node = this.node;\n  if (!node) return;\n  const trailing = node.trailingComments;\n  const leading = node.leadingComments;\n  if (!trailing && !leading) return;\n  const prev = this.getSibling(this.key - 1);\n  const next = this.getSibling(this.key + 1);\n  const hasPrev = Boolean(prev.node);\n  const hasNext = Boolean(next.node);\n\n  if (hasPrev && !hasNext) {\n    prev.addComments(\"trailing\", trailing);\n  } else if (hasNext && !hasPrev) {\n    next.addComments(\"leading\", leading);\n  }\n}\n\nfunction addComment(type, content, line) {\n  _addComment(this.node, type, content, line);\n}\n\nfunction addComments(type, comments) {\n  _addComments(this.node, type, comments);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  DEPRECATED_KEYS,\n  FLIPPED_ALIAS_KEYS,\n  TYPES\n} = _t;\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nclass Hub {\n  getCode() {}\n\n  getScope() {}\n\n  addHelper() {\n    throw new Error(\"Helpers are not supported by the default hub.\");\n  }\n\n  buildError(node, msg, Error = TypeError) {\n    return new Error(msg);\n  }\n\n}\n\nexports.default = Hub;"],"sourceRoot":""}