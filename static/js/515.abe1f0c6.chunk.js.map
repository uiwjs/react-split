{"version":3,"sources":["../node_modules/codemirror/mode/smalltalk/smalltalk.js"],"names":["CodeMirror","defineMode","config","specialChars","keywords","Context","tokenizer","parent","this","next","Token","name","context","eos","State","expectVariable","indentation","userIndentationDelta","prototype","userIndent","indentUnit","stream","state","token","aChar","nextComment","nextString","peek","nextSymbol","eatWhile","nextTemporaries","test","Math","max","current","eat","startState","eatSpace","blankLine","indent","textAfter","i","charAt","electricChars","defineMIME","mod"],"mappings":"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","file":"static/js/515.abe1f0c6.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode('smalltalk', function (config) {\n    var specialChars = /[+\\-\\/\\\\*~<>=@%|&?!.,:;^]/;\n    var keywords = /true|false|nil|self|super|thisContext/;\n\n    var Context = function Context(tokenizer, parent) {\n      this.next = tokenizer;\n      this.parent = parent;\n    };\n\n    var Token = function Token(name, context, eos) {\n      this.name = name;\n      this.context = context;\n      this.eos = eos;\n    };\n\n    var State = function State() {\n      this.context = new Context(next, null);\n      this.expectVariable = true;\n      this.indentation = 0;\n      this.userIndentationDelta = 0;\n    };\n\n    State.prototype.userIndent = function (indentation) {\n      this.userIndentationDelta = indentation > 0 ? indentation / config.indentUnit - this.indentation : 0;\n    };\n\n    var next = function next(stream, context, state) {\n      var token = new Token(null, context, false);\n      var aChar = stream.next();\n\n      if (aChar === '\"') {\n        token = nextComment(stream, new Context(nextComment, context));\n      } else if (aChar === '\\'') {\n        token = nextString(stream, new Context(nextString, context));\n      } else if (aChar === '#') {\n        if (stream.peek() === '\\'') {\n          stream.next();\n          token = nextSymbol(stream, new Context(nextSymbol, context));\n        } else {\n          if (stream.eatWhile(/[^\\s.{}\\[\\]()]/)) token.name = 'string-2';else token.name = 'meta';\n        }\n      } else if (aChar === '$') {\n        if (stream.next() === '<') {\n          stream.eatWhile(/[^\\s>]/);\n          stream.next();\n        }\n\n        token.name = 'string-2';\n      } else if (aChar === '|' && state.expectVariable) {\n        token.context = new Context(nextTemporaries, context);\n      } else if (/[\\[\\]{}()]/.test(aChar)) {\n        token.name = 'bracket';\n        token.eos = /[\\[{(]/.test(aChar);\n\n        if (aChar === '[') {\n          state.indentation++;\n        } else if (aChar === ']') {\n          state.indentation = Math.max(0, state.indentation - 1);\n        }\n      } else if (specialChars.test(aChar)) {\n        stream.eatWhile(specialChars);\n        token.name = 'operator';\n        token.eos = aChar !== ';'; // ; cascaded message expression\n      } else if (/\\d/.test(aChar)) {\n        stream.eatWhile(/[\\w\\d]/);\n        token.name = 'number';\n      } else if (/[\\w_]/.test(aChar)) {\n        stream.eatWhile(/[\\w\\d_]/);\n        token.name = state.expectVariable ? keywords.test(stream.current()) ? 'keyword' : 'variable' : null;\n      } else {\n        token.eos = state.expectVariable;\n      }\n\n      return token;\n    };\n\n    var nextComment = function nextComment(stream, context) {\n      stream.eatWhile(/[^\"]/);\n      return new Token('comment', stream.eat('\"') ? context.parent : context, true);\n    };\n\n    var nextString = function nextString(stream, context) {\n      stream.eatWhile(/[^']/);\n      return new Token('string', stream.eat('\\'') ? context.parent : context, false);\n    };\n\n    var nextSymbol = function nextSymbol(stream, context) {\n      stream.eatWhile(/[^']/);\n      return new Token('string-2', stream.eat('\\'') ? context.parent : context, false);\n    };\n\n    var nextTemporaries = function nextTemporaries(stream, context) {\n      var token = new Token(null, context, false);\n      var aChar = stream.next();\n\n      if (aChar === '|') {\n        token.context = context.parent;\n        token.eos = true;\n      } else {\n        stream.eatWhile(/[^|]/);\n        token.name = 'variable';\n      }\n\n      return token;\n    };\n\n    return {\n      startState: function startState() {\n        return new State();\n      },\n      token: function token(stream, state) {\n        state.userIndent(stream.indentation());\n\n        if (stream.eatSpace()) {\n          return null;\n        }\n\n        var token = state.context.next(stream, state.context, state);\n        state.context = token.context;\n        state.expectVariable = token.eos;\n        return token.name;\n      },\n      blankLine: function blankLine(state) {\n        state.userIndent(0);\n      },\n      indent: function indent(state, textAfter) {\n        var i = state.context.next === next && textAfter && textAfter.charAt(0) === ']' ? -1 : state.userIndentationDelta;\n        return (state.indentation + i) * config.indentUnit;\n      },\n      electricChars: ']'\n    };\n  });\n  CodeMirror.defineMIME('text/x-stsrc', {\n    name: 'smalltalk'\n  });\n});"],"sourceRoot":""}